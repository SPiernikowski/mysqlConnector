// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mysqlx_expr.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mysqlx_5fexpr_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mysqlx_5fexpr_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "mysqlx_datatypes.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mysqlx_5fexpr_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mysqlx_5fexpr_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace Mysqlx {
namespace Expr {
class Array;
class ArrayDefaultTypeInternal;
extern ArrayDefaultTypeInternal _Array_default_instance_;
class ColumnIdentifier;
class ColumnIdentifierDefaultTypeInternal;
extern ColumnIdentifierDefaultTypeInternal _ColumnIdentifier_default_instance_;
class DocumentPathItem;
class DocumentPathItemDefaultTypeInternal;
extern DocumentPathItemDefaultTypeInternal _DocumentPathItem_default_instance_;
class Expr;
class ExprDefaultTypeInternal;
extern ExprDefaultTypeInternal _Expr_default_instance_;
class FunctionCall;
class FunctionCallDefaultTypeInternal;
extern FunctionCallDefaultTypeInternal _FunctionCall_default_instance_;
class Identifier;
class IdentifierDefaultTypeInternal;
extern IdentifierDefaultTypeInternal _Identifier_default_instance_;
class Object;
class ObjectDefaultTypeInternal;
extern ObjectDefaultTypeInternal _Object_default_instance_;
class Object_ObjectField;
class Object_ObjectFieldDefaultTypeInternal;
extern Object_ObjectFieldDefaultTypeInternal _Object_ObjectField_default_instance_;
class Operator;
class OperatorDefaultTypeInternal;
extern OperatorDefaultTypeInternal _Operator_default_instance_;
}  // namespace Expr
}  // namespace Mysqlx
PROTOBUF_NAMESPACE_OPEN
template<> ::Mysqlx::Expr::Array* Arena::CreateMaybeMessage<::Mysqlx::Expr::Array>(Arena*);
template<> ::Mysqlx::Expr::ColumnIdentifier* Arena::CreateMaybeMessage<::Mysqlx::Expr::ColumnIdentifier>(Arena*);
template<> ::Mysqlx::Expr::DocumentPathItem* Arena::CreateMaybeMessage<::Mysqlx::Expr::DocumentPathItem>(Arena*);
template<> ::Mysqlx::Expr::Expr* Arena::CreateMaybeMessage<::Mysqlx::Expr::Expr>(Arena*);
template<> ::Mysqlx::Expr::FunctionCall* Arena::CreateMaybeMessage<::Mysqlx::Expr::FunctionCall>(Arena*);
template<> ::Mysqlx::Expr::Identifier* Arena::CreateMaybeMessage<::Mysqlx::Expr::Identifier>(Arena*);
template<> ::Mysqlx::Expr::Object* Arena::CreateMaybeMessage<::Mysqlx::Expr::Object>(Arena*);
template<> ::Mysqlx::Expr::Object_ObjectField* Arena::CreateMaybeMessage<::Mysqlx::Expr::Object_ObjectField>(Arena*);
template<> ::Mysqlx::Expr::Operator* Arena::CreateMaybeMessage<::Mysqlx::Expr::Operator>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Mysqlx {
namespace Expr {

enum Expr_Type : int {
  Expr_Type_IDENT = 1,
  Expr_Type_LITERAL = 2,
  Expr_Type_VARIABLE = 3,
  Expr_Type_FUNC_CALL = 4,
  Expr_Type_OPERATOR = 5,
  Expr_Type_PLACEHOLDER = 6,
  Expr_Type_OBJECT = 7,
  Expr_Type_ARRAY = 8
};
bool Expr_Type_IsValid(int value);
constexpr Expr_Type Expr_Type_Type_MIN = Expr_Type_IDENT;
constexpr Expr_Type Expr_Type_Type_MAX = Expr_Type_ARRAY;
constexpr int Expr_Type_Type_ARRAYSIZE = Expr_Type_Type_MAX + 1;

const std::string& Expr_Type_Name(Expr_Type value);
template<typename T>
inline const std::string& Expr_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Expr_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Expr_Type_Name.");
  return Expr_Type_Name(static_cast<Expr_Type>(enum_t_value));
}
bool Expr_Type_Parse(
    const std::string& name, Expr_Type* value);
enum DocumentPathItem_Type : int {
  DocumentPathItem_Type_MEMBER = 1,
  DocumentPathItem_Type_MEMBER_ASTERISK = 2,
  DocumentPathItem_Type_ARRAY_INDEX = 3,
  DocumentPathItem_Type_ARRAY_INDEX_ASTERISK = 4,
  DocumentPathItem_Type_DOUBLE_ASTERISK = 5
};
bool DocumentPathItem_Type_IsValid(int value);
constexpr DocumentPathItem_Type DocumentPathItem_Type_Type_MIN = DocumentPathItem_Type_MEMBER;
constexpr DocumentPathItem_Type DocumentPathItem_Type_Type_MAX = DocumentPathItem_Type_DOUBLE_ASTERISK;
constexpr int DocumentPathItem_Type_Type_ARRAYSIZE = DocumentPathItem_Type_Type_MAX + 1;

const std::string& DocumentPathItem_Type_Name(DocumentPathItem_Type value);
template<typename T>
inline const std::string& DocumentPathItem_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DocumentPathItem_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DocumentPathItem_Type_Name.");
  return DocumentPathItem_Type_Name(static_cast<DocumentPathItem_Type>(enum_t_value));
}
bool DocumentPathItem_Type_Parse(
    const std::string& name, DocumentPathItem_Type* value);
// ===================================================================

class Expr :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Expr.Expr) */ {
 public:
  Expr();
  virtual ~Expr();

  Expr(const Expr& from);
  Expr(Expr&& from) noexcept
    : Expr() {
    *this = ::std::move(from);
  }

  inline Expr& operator=(const Expr& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expr& operator=(Expr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Expr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expr* internal_default_instance() {
    return reinterpret_cast<const Expr*>(
               &_Expr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Expr& a, Expr& b) {
    a.Swap(&b);
  }
  inline void Swap(Expr* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Expr* New() const final {
    return CreateMaybeMessage<Expr>(nullptr);
  }

  Expr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Expr>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Expr& from);
  void MergeFrom(const Expr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Expr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mysqlx.Expr.Expr";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Expr_Type Type;
  static constexpr Type IDENT =
    Expr_Type_IDENT;
  static constexpr Type LITERAL =
    Expr_Type_LITERAL;
  static constexpr Type VARIABLE =
    Expr_Type_VARIABLE;
  static constexpr Type FUNC_CALL =
    Expr_Type_FUNC_CALL;
  static constexpr Type OPERATOR =
    Expr_Type_OPERATOR;
  static constexpr Type PLACEHOLDER =
    Expr_Type_PLACEHOLDER;
  static constexpr Type OBJECT =
    Expr_Type_OBJECT;
  static constexpr Type ARRAY =
    Expr_Type_ARRAY;
  static inline bool Type_IsValid(int value) {
    return Expr_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Expr_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Expr_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Expr_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Expr_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return Expr_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVariableFieldNumber = 3,
    kIdentifierFieldNumber = 2,
    kLiteralFieldNumber = 4,
    kFunctionCallFieldNumber = 5,
    kOperatorFieldNumber = 6,
    kObjectFieldNumber = 8,
    kArrayFieldNumber = 9,
    kPositionFieldNumber = 7,
    kTypeFieldNumber = 1,
  };
  // optional string variable = 3;
  bool has_variable() const;
  private:
  bool _internal_has_variable() const;
  public:
  void clear_variable();
  const std::string& variable() const;
  void set_variable(const std::string& value);
  void set_variable(std::string&& value);
  void set_variable(const char* value);
  void set_variable(const char* value, size_t size);
  std::string* mutable_variable();
  std::string* release_variable();
  void set_allocated_variable(std::string* variable);
  private:
  const std::string& _internal_variable() const;
  void _internal_set_variable(const std::string& value);
  std::string* _internal_mutable_variable();
  public:

  // optional .Mysqlx.Expr.ColumnIdentifier identifier = 2;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const ::Mysqlx::Expr::ColumnIdentifier& identifier() const;
  ::Mysqlx::Expr::ColumnIdentifier* release_identifier();
  ::Mysqlx::Expr::ColumnIdentifier* mutable_identifier();
  void set_allocated_identifier(::Mysqlx::Expr::ColumnIdentifier* identifier);
  private:
  const ::Mysqlx::Expr::ColumnIdentifier& _internal_identifier() const;
  ::Mysqlx::Expr::ColumnIdentifier* _internal_mutable_identifier();
  public:

  // optional .Mysqlx.Datatypes.Scalar literal = 4;
  bool has_literal() const;
  private:
  bool _internal_has_literal() const;
  public:
  void clear_literal();
  const ::Mysqlx::Datatypes::Scalar& literal() const;
  ::Mysqlx::Datatypes::Scalar* release_literal();
  ::Mysqlx::Datatypes::Scalar* mutable_literal();
  void set_allocated_literal(::Mysqlx::Datatypes::Scalar* literal);
  private:
  const ::Mysqlx::Datatypes::Scalar& _internal_literal() const;
  ::Mysqlx::Datatypes::Scalar* _internal_mutable_literal();
  public:

  // optional .Mysqlx.Expr.FunctionCall function_call = 5;
  bool has_function_call() const;
  private:
  bool _internal_has_function_call() const;
  public:
  void clear_function_call();
  const ::Mysqlx::Expr::FunctionCall& function_call() const;
  ::Mysqlx::Expr::FunctionCall* release_function_call();
  ::Mysqlx::Expr::FunctionCall* mutable_function_call();
  void set_allocated_function_call(::Mysqlx::Expr::FunctionCall* function_call);
  private:
  const ::Mysqlx::Expr::FunctionCall& _internal_function_call() const;
  ::Mysqlx::Expr::FunctionCall* _internal_mutable_function_call();
  public:

  // optional .Mysqlx.Expr.Operator operator = 6;
  bool has_operator_() const;
  private:
  bool _internal_has_operator_() const;
  public:
  void clear_operator_();
  const ::Mysqlx::Expr::Operator& operator_() const;
  ::Mysqlx::Expr::Operator* release_operator_();
  ::Mysqlx::Expr::Operator* mutable_operator_();
  void set_allocated_operator_(::Mysqlx::Expr::Operator* operator_);
  private:
  const ::Mysqlx::Expr::Operator& _internal_operator_() const;
  ::Mysqlx::Expr::Operator* _internal_mutable_operator_();
  public:

  // optional .Mysqlx.Expr.Object object = 8;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::Mysqlx::Expr::Object& object() const;
  ::Mysqlx::Expr::Object* release_object();
  ::Mysqlx::Expr::Object* mutable_object();
  void set_allocated_object(::Mysqlx::Expr::Object* object);
  private:
  const ::Mysqlx::Expr::Object& _internal_object() const;
  ::Mysqlx::Expr::Object* _internal_mutable_object();
  public:

  // optional .Mysqlx.Expr.Array array = 9;
  bool has_array() const;
  private:
  bool _internal_has_array() const;
  public:
  void clear_array();
  const ::Mysqlx::Expr::Array& array() const;
  ::Mysqlx::Expr::Array* release_array();
  ::Mysqlx::Expr::Array* mutable_array();
  void set_allocated_array(::Mysqlx::Expr::Array* array);
  private:
  const ::Mysqlx::Expr::Array& _internal_array() const;
  ::Mysqlx::Expr::Array* _internal_mutable_array();
  public:

  // optional uint32 position = 7;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  ::PROTOBUF_NAMESPACE_ID::uint32 position() const;
  void set_position(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_position() const;
  void _internal_set_position(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required .Mysqlx.Expr.Expr.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::Mysqlx::Expr::Expr_Type type() const;
  void set_type(::Mysqlx::Expr::Expr_Type value);
  private:
  ::Mysqlx::Expr::Expr_Type _internal_type() const;
  void _internal_set_type(::Mysqlx::Expr::Expr_Type value);
  public:

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.Expr)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr variable_;
  ::Mysqlx::Expr::ColumnIdentifier* identifier_;
  ::Mysqlx::Datatypes::Scalar* literal_;
  ::Mysqlx::Expr::FunctionCall* function_call_;
  ::Mysqlx::Expr::Operator* operator__;
  ::Mysqlx::Expr::Object* object_;
  ::Mysqlx::Expr::Array* array_;
  ::PROTOBUF_NAMESPACE_ID::uint32 position_;
  int type_;
  friend struct ::TableStruct_mysqlx_5fexpr_2eproto;
};
// -------------------------------------------------------------------

class Identifier :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Expr.Identifier) */ {
 public:
  Identifier();
  virtual ~Identifier();

  Identifier(const Identifier& from);
  Identifier(Identifier&& from) noexcept
    : Identifier() {
    *this = ::std::move(from);
  }

  inline Identifier& operator=(const Identifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline Identifier& operator=(Identifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Identifier& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Identifier* internal_default_instance() {
    return reinterpret_cast<const Identifier*>(
               &_Identifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Identifier& a, Identifier& b) {
    a.Swap(&b);
  }
  inline void Swap(Identifier* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Identifier* New() const final {
    return CreateMaybeMessage<Identifier>(nullptr);
  }

  Identifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Identifier>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Identifier& from);
  void MergeFrom(const Identifier& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Identifier* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mysqlx.Expr.Identifier";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string schema_name = 2;
  bool has_schema_name() const;
  private:
  bool _internal_has_schema_name() const;
  public:
  void clear_schema_name();
  const std::string& schema_name() const;
  void set_schema_name(const std::string& value);
  void set_schema_name(std::string&& value);
  void set_schema_name(const char* value);
  void set_schema_name(const char* value, size_t size);
  std::string* mutable_schema_name();
  std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.Identifier)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
  friend struct ::TableStruct_mysqlx_5fexpr_2eproto;
};
// -------------------------------------------------------------------

class DocumentPathItem :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Expr.DocumentPathItem) */ {
 public:
  DocumentPathItem();
  virtual ~DocumentPathItem();

  DocumentPathItem(const DocumentPathItem& from);
  DocumentPathItem(DocumentPathItem&& from) noexcept
    : DocumentPathItem() {
    *this = ::std::move(from);
  }

  inline DocumentPathItem& operator=(const DocumentPathItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocumentPathItem& operator=(DocumentPathItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DocumentPathItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DocumentPathItem* internal_default_instance() {
    return reinterpret_cast<const DocumentPathItem*>(
               &_DocumentPathItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DocumentPathItem& a, DocumentPathItem& b) {
    a.Swap(&b);
  }
  inline void Swap(DocumentPathItem* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DocumentPathItem* New() const final {
    return CreateMaybeMessage<DocumentPathItem>(nullptr);
  }

  DocumentPathItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DocumentPathItem>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DocumentPathItem& from);
  void MergeFrom(const DocumentPathItem& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DocumentPathItem* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mysqlx.Expr.DocumentPathItem";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DocumentPathItem_Type Type;
  static constexpr Type MEMBER =
    DocumentPathItem_Type_MEMBER;
  static constexpr Type MEMBER_ASTERISK =
    DocumentPathItem_Type_MEMBER_ASTERISK;
  static constexpr Type ARRAY_INDEX =
    DocumentPathItem_Type_ARRAY_INDEX;
  static constexpr Type ARRAY_INDEX_ASTERISK =
    DocumentPathItem_Type_ARRAY_INDEX_ASTERISK;
  static constexpr Type DOUBLE_ASTERISK =
    DocumentPathItem_Type_DOUBLE_ASTERISK;
  static inline bool Type_IsValid(int value) {
    return DocumentPathItem_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    DocumentPathItem_Type_Type_MIN;
  static constexpr Type Type_MAX =
    DocumentPathItem_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    DocumentPathItem_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return DocumentPathItem_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return DocumentPathItem_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kIndexFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // optional string value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional uint32 index = 3;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  ::PROTOBUF_NAMESPACE_ID::uint32 index() const;
  void set_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_index() const;
  void _internal_set_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required .Mysqlx.Expr.DocumentPathItem.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::Mysqlx::Expr::DocumentPathItem_Type type() const;
  void set_type(::Mysqlx::Expr::DocumentPathItem_Type value);
  private:
  ::Mysqlx::Expr::DocumentPathItem_Type _internal_type() const;
  void _internal_set_type(::Mysqlx::Expr::DocumentPathItem_Type value);
  public:

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.DocumentPathItem)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::uint32 index_;
  int type_;
  friend struct ::TableStruct_mysqlx_5fexpr_2eproto;
};
// -------------------------------------------------------------------

class ColumnIdentifier :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Expr.ColumnIdentifier) */ {
 public:
  ColumnIdentifier();
  virtual ~ColumnIdentifier();

  ColumnIdentifier(const ColumnIdentifier& from);
  ColumnIdentifier(ColumnIdentifier&& from) noexcept
    : ColumnIdentifier() {
    *this = ::std::move(from);
  }

  inline ColumnIdentifier& operator=(const ColumnIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnIdentifier& operator=(ColumnIdentifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ColumnIdentifier& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ColumnIdentifier* internal_default_instance() {
    return reinterpret_cast<const ColumnIdentifier*>(
               &_ColumnIdentifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ColumnIdentifier& a, ColumnIdentifier& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnIdentifier* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ColumnIdentifier* New() const final {
    return CreateMaybeMessage<ColumnIdentifier>(nullptr);
  }

  ColumnIdentifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ColumnIdentifier>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ColumnIdentifier& from);
  void MergeFrom(const ColumnIdentifier& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ColumnIdentifier* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mysqlx.Expr.ColumnIdentifier";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentPathFieldNumber = 1,
    kNameFieldNumber = 2,
    kTableNameFieldNumber = 3,
    kSchemaNameFieldNumber = 4,
  };
  // repeated .Mysqlx.Expr.DocumentPathItem document_path = 1;
  int document_path_size() const;
  private:
  int _internal_document_path_size() const;
  public:
  void clear_document_path();
  ::Mysqlx::Expr::DocumentPathItem* mutable_document_path(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >*
      mutable_document_path();
  private:
  const ::Mysqlx::Expr::DocumentPathItem& _internal_document_path(int index) const;
  ::Mysqlx::Expr::DocumentPathItem* _internal_add_document_path();
  public:
  const ::Mysqlx::Expr::DocumentPathItem& document_path(int index) const;
  ::Mysqlx::Expr::DocumentPathItem* add_document_path();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >&
      document_path() const;

  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string table_name = 3;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const std::string& table_name() const;
  void set_table_name(const std::string& value);
  void set_table_name(std::string&& value);
  void set_table_name(const char* value);
  void set_table_name(const char* value, size_t size);
  std::string* mutable_table_name();
  std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // optional string schema_name = 4;
  bool has_schema_name() const;
  private:
  bool _internal_has_schema_name() const;
  public:
  void clear_schema_name();
  const std::string& schema_name() const;
  void set_schema_name(const std::string& value);
  void set_schema_name(std::string&& value);
  void set_schema_name(const char* value);
  void set_schema_name(const char* value, size_t size);
  std::string* mutable_schema_name();
  std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.ColumnIdentifier)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem > document_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
  friend struct ::TableStruct_mysqlx_5fexpr_2eproto;
};
// -------------------------------------------------------------------

class FunctionCall :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Expr.FunctionCall) */ {
 public:
  FunctionCall();
  virtual ~FunctionCall();

  FunctionCall(const FunctionCall& from);
  FunctionCall(FunctionCall&& from) noexcept
    : FunctionCall() {
    *this = ::std::move(from);
  }

  inline FunctionCall& operator=(const FunctionCall& from) {
    CopyFrom(from);
    return *this;
  }
  inline FunctionCall& operator=(FunctionCall&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FunctionCall& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FunctionCall* internal_default_instance() {
    return reinterpret_cast<const FunctionCall*>(
               &_FunctionCall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FunctionCall& a, FunctionCall& b) {
    a.Swap(&b);
  }
  inline void Swap(FunctionCall* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FunctionCall* New() const final {
    return CreateMaybeMessage<FunctionCall>(nullptr);
  }

  FunctionCall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FunctionCall>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const FunctionCall& from);
  void MergeFrom(const FunctionCall& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FunctionCall* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mysqlx.Expr.FunctionCall";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .Mysqlx.Expr.Expr param = 2;
  int param_size() const;
  private:
  int _internal_param_size() const;
  public:
  void clear_param();
  ::Mysqlx::Expr::Expr* mutable_param(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
      mutable_param();
  private:
  const ::Mysqlx::Expr::Expr& _internal_param(int index) const;
  ::Mysqlx::Expr::Expr* _internal_add_param();
  public:
  const ::Mysqlx::Expr::Expr& param(int index) const;
  ::Mysqlx::Expr::Expr* add_param();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
      param() const;

  // required .Mysqlx.Expr.Identifier name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const ::Mysqlx::Expr::Identifier& name() const;
  ::Mysqlx::Expr::Identifier* release_name();
  ::Mysqlx::Expr::Identifier* mutable_name();
  void set_allocated_name(::Mysqlx::Expr::Identifier* name);
  private:
  const ::Mysqlx::Expr::Identifier& _internal_name() const;
  ::Mysqlx::Expr::Identifier* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.FunctionCall)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Expr > param_;
  ::Mysqlx::Expr::Identifier* name_;
  friend struct ::TableStruct_mysqlx_5fexpr_2eproto;
};
// -------------------------------------------------------------------

class Operator :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Expr.Operator) */ {
 public:
  Operator();
  virtual ~Operator();

  Operator(const Operator& from);
  Operator(Operator&& from) noexcept
    : Operator() {
    *this = ::std::move(from);
  }

  inline Operator& operator=(const Operator& from) {
    CopyFrom(from);
    return *this;
  }
  inline Operator& operator=(Operator&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Operator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Operator* internal_default_instance() {
    return reinterpret_cast<const Operator*>(
               &_Operator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Operator& a, Operator& b) {
    a.Swap(&b);
  }
  inline void Swap(Operator* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Operator* New() const final {
    return CreateMaybeMessage<Operator>(nullptr);
  }

  Operator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Operator>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Operator& from);
  void MergeFrom(const Operator& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Operator* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mysqlx.Expr.Operator";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .Mysqlx.Expr.Expr param = 2;
  int param_size() const;
  private:
  int _internal_param_size() const;
  public:
  void clear_param();
  ::Mysqlx::Expr::Expr* mutable_param(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
      mutable_param();
  private:
  const ::Mysqlx::Expr::Expr& _internal_param(int index) const;
  ::Mysqlx::Expr::Expr* _internal_add_param();
  public:
  const ::Mysqlx::Expr::Expr& param(int index) const;
  ::Mysqlx::Expr::Expr* add_param();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
      param() const;

  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.Operator)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Expr > param_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  friend struct ::TableStruct_mysqlx_5fexpr_2eproto;
};
// -------------------------------------------------------------------

class Object_ObjectField :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Expr.Object.ObjectField) */ {
 public:
  Object_ObjectField();
  virtual ~Object_ObjectField();

  Object_ObjectField(const Object_ObjectField& from);
  Object_ObjectField(Object_ObjectField&& from) noexcept
    : Object_ObjectField() {
    *this = ::std::move(from);
  }

  inline Object_ObjectField& operator=(const Object_ObjectField& from) {
    CopyFrom(from);
    return *this;
  }
  inline Object_ObjectField& operator=(Object_ObjectField&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Object_ObjectField& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Object_ObjectField* internal_default_instance() {
    return reinterpret_cast<const Object_ObjectField*>(
               &_Object_ObjectField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Object_ObjectField& a, Object_ObjectField& b) {
    a.Swap(&b);
  }
  inline void Swap(Object_ObjectField* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Object_ObjectField* New() const final {
    return CreateMaybeMessage<Object_ObjectField>(nullptr);
  }

  Object_ObjectField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Object_ObjectField>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Object_ObjectField& from);
  void MergeFrom(const Object_ObjectField& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Object_ObjectField* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mysqlx.Expr.Object.ObjectField";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // required string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // required .Mysqlx.Expr.Expr value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::Mysqlx::Expr::Expr& value() const;
  ::Mysqlx::Expr::Expr* release_value();
  ::Mysqlx::Expr::Expr* mutable_value();
  void set_allocated_value(::Mysqlx::Expr::Expr* value);
  private:
  const ::Mysqlx::Expr::Expr& _internal_value() const;
  ::Mysqlx::Expr::Expr* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.Object.ObjectField)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::Mysqlx::Expr::Expr* value_;
  friend struct ::TableStruct_mysqlx_5fexpr_2eproto;
};
// -------------------------------------------------------------------

class Object :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Expr.Object) */ {
 public:
  Object();
  virtual ~Object();

  Object(const Object& from);
  Object(Object&& from) noexcept
    : Object() {
    *this = ::std::move(from);
  }

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }
  inline Object& operator=(Object&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Object& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Object* internal_default_instance() {
    return reinterpret_cast<const Object*>(
               &_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Object& a, Object& b) {
    a.Swap(&b);
  }
  inline void Swap(Object* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Object* New() const final {
    return CreateMaybeMessage<Object>(nullptr);
  }

  Object* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Object>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Object& from);
  void MergeFrom(const Object& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Object* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mysqlx.Expr.Object";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Object_ObjectField ObjectField;

  // accessors -------------------------------------------------------

  enum : int {
    kFldFieldNumber = 1,
  };
  // repeated .Mysqlx.Expr.Object.ObjectField fld = 1;
  int fld_size() const;
  private:
  int _internal_fld_size() const;
  public:
  void clear_fld();
  ::Mysqlx::Expr::Object_ObjectField* mutable_fld(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Object_ObjectField >*
      mutable_fld();
  private:
  const ::Mysqlx::Expr::Object_ObjectField& _internal_fld(int index) const;
  ::Mysqlx::Expr::Object_ObjectField* _internal_add_fld();
  public:
  const ::Mysqlx::Expr::Object_ObjectField& fld(int index) const;
  ::Mysqlx::Expr::Object_ObjectField* add_fld();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Object_ObjectField >&
      fld() const;

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.Object)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Object_ObjectField > fld_;
  friend struct ::TableStruct_mysqlx_5fexpr_2eproto;
};
// -------------------------------------------------------------------

class Array :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Expr.Array) */ {
 public:
  Array();
  virtual ~Array();

  Array(const Array& from);
  Array(Array&& from) noexcept
    : Array() {
    *this = ::std::move(from);
  }

  inline Array& operator=(const Array& from) {
    CopyFrom(from);
    return *this;
  }
  inline Array& operator=(Array&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Array& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Array* internal_default_instance() {
    return reinterpret_cast<const Array*>(
               &_Array_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Array& a, Array& b) {
    a.Swap(&b);
  }
  inline void Swap(Array* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Array* New() const final {
    return CreateMaybeMessage<Array>(nullptr);
  }

  Array* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Array>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Array& from);
  void MergeFrom(const Array& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Array* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mysqlx.Expr.Array";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated .Mysqlx.Expr.Expr value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  ::Mysqlx::Expr::Expr* mutable_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
      mutable_value();
  private:
  const ::Mysqlx::Expr::Expr& _internal_value(int index) const;
  ::Mysqlx::Expr::Expr* _internal_add_value();
  public:
  const ::Mysqlx::Expr::Expr& value(int index) const;
  ::Mysqlx::Expr::Expr* add_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
      value() const;

  // @@protoc_insertion_point(class_scope:Mysqlx.Expr.Array)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Expr > value_;
  friend struct ::TableStruct_mysqlx_5fexpr_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Expr

// required .Mysqlx.Expr.Expr.Type type = 1;
inline bool Expr::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Expr::has_type() const {
  return _internal_has_type();
}
inline void Expr::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::Mysqlx::Expr::Expr_Type Expr::_internal_type() const {
  return static_cast< ::Mysqlx::Expr::Expr_Type >(type_);
}
inline ::Mysqlx::Expr::Expr_Type Expr::type() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.type)
  return _internal_type();
}
inline void Expr::_internal_set_type(::Mysqlx::Expr::Expr_Type value) {
  assert(::Mysqlx::Expr::Expr_Type_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  type_ = value;
}
inline void Expr::set_type(::Mysqlx::Expr::Expr_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.Expr.type)
}

// optional .Mysqlx.Expr.ColumnIdentifier identifier = 2;
inline bool Expr::_internal_has_identifier() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || identifier_ != nullptr);
  return value;
}
inline bool Expr::has_identifier() const {
  return _internal_has_identifier();
}
inline void Expr::clear_identifier() {
  if (identifier_ != nullptr) identifier_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::Mysqlx::Expr::ColumnIdentifier& Expr::_internal_identifier() const {
  const ::Mysqlx::Expr::ColumnIdentifier* p = identifier_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Expr::ColumnIdentifier*>(
      &::Mysqlx::Expr::_ColumnIdentifier_default_instance_);
}
inline const ::Mysqlx::Expr::ColumnIdentifier& Expr::identifier() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.identifier)
  return _internal_identifier();
}
inline ::Mysqlx::Expr::ColumnIdentifier* Expr::release_identifier() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Expr.identifier)
  _has_bits_[0] &= ~0x00000002u;
  ::Mysqlx::Expr::ColumnIdentifier* temp = identifier_;
  identifier_ = nullptr;
  return temp;
}
inline ::Mysqlx::Expr::ColumnIdentifier* Expr::_internal_mutable_identifier() {
  _has_bits_[0] |= 0x00000002u;
  if (identifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::ColumnIdentifier>(GetArenaNoVirtual());
    identifier_ = p;
  }
  return identifier_;
}
inline ::Mysqlx::Expr::ColumnIdentifier* Expr::mutable_identifier() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Expr.identifier)
  return _internal_mutable_identifier();
}
inline void Expr::set_allocated_identifier(::Mysqlx::Expr::ColumnIdentifier* identifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete identifier_;
  }
  if (identifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      identifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identifier, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  identifier_ = identifier;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Expr.identifier)
}

// optional string variable = 3;
inline bool Expr::_internal_has_variable() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Expr::has_variable() const {
  return _internal_has_variable();
}
inline void Expr::clear_variable() {
  variable_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Expr::variable() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.variable)
  return _internal_variable();
}
inline void Expr::set_variable(const std::string& value) {
  _internal_set_variable(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.Expr.variable)
}
inline std::string* Expr::mutable_variable() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Expr.variable)
  return _internal_mutable_variable();
}
inline const std::string& Expr::_internal_variable() const {
  return variable_.GetNoArena();
}
inline void Expr::_internal_set_variable(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  variable_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Expr::set_variable(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  variable_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Expr.Expr.variable)
}
inline void Expr::set_variable(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  variable_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.Expr.variable)
}
inline void Expr::set_variable(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  variable_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.Expr.variable)
}
inline std::string* Expr::_internal_mutable_variable() {
  _has_bits_[0] |= 0x00000001u;
  return variable_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Expr::release_variable() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Expr.variable)
  if (!_internal_has_variable()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return variable_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Expr::set_allocated_variable(std::string* variable) {
  if (variable != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  variable_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), variable);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Expr.variable)
}

// optional .Mysqlx.Datatypes.Scalar literal = 4;
inline bool Expr::_internal_has_literal() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || literal_ != nullptr);
  return value;
}
inline bool Expr::has_literal() const {
  return _internal_has_literal();
}
inline const ::Mysqlx::Datatypes::Scalar& Expr::_internal_literal() const {
  const ::Mysqlx::Datatypes::Scalar* p = literal_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Datatypes::Scalar*>(
      &::Mysqlx::Datatypes::_Scalar_default_instance_);
}
inline const ::Mysqlx::Datatypes::Scalar& Expr::literal() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.literal)
  return _internal_literal();
}
inline ::Mysqlx::Datatypes::Scalar* Expr::release_literal() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Expr.literal)
  _has_bits_[0] &= ~0x00000004u;
  ::Mysqlx::Datatypes::Scalar* temp = literal_;
  literal_ = nullptr;
  return temp;
}
inline ::Mysqlx::Datatypes::Scalar* Expr::_internal_mutable_literal() {
  _has_bits_[0] |= 0x00000004u;
  if (literal_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Datatypes::Scalar>(GetArenaNoVirtual());
    literal_ = p;
  }
  return literal_;
}
inline ::Mysqlx::Datatypes::Scalar* Expr::mutable_literal() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Expr.literal)
  return _internal_mutable_literal();
}
inline void Expr::set_allocated_literal(::Mysqlx::Datatypes::Scalar* literal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(literal_);
  }
  if (literal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      literal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, literal, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  literal_ = literal;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Expr.literal)
}

// optional .Mysqlx.Expr.FunctionCall function_call = 5;
inline bool Expr::_internal_has_function_call() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || function_call_ != nullptr);
  return value;
}
inline bool Expr::has_function_call() const {
  return _internal_has_function_call();
}
inline void Expr::clear_function_call() {
  if (function_call_ != nullptr) function_call_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::Mysqlx::Expr::FunctionCall& Expr::_internal_function_call() const {
  const ::Mysqlx::Expr::FunctionCall* p = function_call_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Expr::FunctionCall*>(
      &::Mysqlx::Expr::_FunctionCall_default_instance_);
}
inline const ::Mysqlx::Expr::FunctionCall& Expr::function_call() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.function_call)
  return _internal_function_call();
}
inline ::Mysqlx::Expr::FunctionCall* Expr::release_function_call() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Expr.function_call)
  _has_bits_[0] &= ~0x00000008u;
  ::Mysqlx::Expr::FunctionCall* temp = function_call_;
  function_call_ = nullptr;
  return temp;
}
inline ::Mysqlx::Expr::FunctionCall* Expr::_internal_mutable_function_call() {
  _has_bits_[0] |= 0x00000008u;
  if (function_call_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::FunctionCall>(GetArenaNoVirtual());
    function_call_ = p;
  }
  return function_call_;
}
inline ::Mysqlx::Expr::FunctionCall* Expr::mutable_function_call() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Expr.function_call)
  return _internal_mutable_function_call();
}
inline void Expr::set_allocated_function_call(::Mysqlx::Expr::FunctionCall* function_call) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete function_call_;
  }
  if (function_call) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      function_call = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, function_call, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  function_call_ = function_call;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Expr.function_call)
}

// optional .Mysqlx.Expr.Operator operator = 6;
inline bool Expr::_internal_has_operator_() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || operator__ != nullptr);
  return value;
}
inline bool Expr::has_operator_() const {
  return _internal_has_operator_();
}
inline void Expr::clear_operator_() {
  if (operator__ != nullptr) operator__->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::Mysqlx::Expr::Operator& Expr::_internal_operator_() const {
  const ::Mysqlx::Expr::Operator* p = operator__;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Expr::Operator*>(
      &::Mysqlx::Expr::_Operator_default_instance_);
}
inline const ::Mysqlx::Expr::Operator& Expr::operator_() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.operator)
  return _internal_operator_();
}
inline ::Mysqlx::Expr::Operator* Expr::release_operator_() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Expr.operator)
  _has_bits_[0] &= ~0x00000010u;
  ::Mysqlx::Expr::Operator* temp = operator__;
  operator__ = nullptr;
  return temp;
}
inline ::Mysqlx::Expr::Operator* Expr::_internal_mutable_operator_() {
  _has_bits_[0] |= 0x00000010u;
  if (operator__ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::Operator>(GetArenaNoVirtual());
    operator__ = p;
  }
  return operator__;
}
inline ::Mysqlx::Expr::Operator* Expr::mutable_operator_() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Expr.operator)
  return _internal_mutable_operator_();
}
inline void Expr::set_allocated_operator_(::Mysqlx::Expr::Operator* operator_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete operator__;
  }
  if (operator_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      operator_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, operator_, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  operator__ = operator_;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Expr.operator)
}

// optional uint32 position = 7;
inline bool Expr::_internal_has_position() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Expr::has_position() const {
  return _internal_has_position();
}
inline void Expr::clear_position() {
  position_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Expr::_internal_position() const {
  return position_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Expr::position() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.position)
  return _internal_position();
}
inline void Expr::_internal_set_position(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  position_ = value;
}
inline void Expr::set_position(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.Expr.position)
}

// optional .Mysqlx.Expr.Object object = 8;
inline bool Expr::_internal_has_object() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || object_ != nullptr);
  return value;
}
inline bool Expr::has_object() const {
  return _internal_has_object();
}
inline void Expr::clear_object() {
  if (object_ != nullptr) object_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::Mysqlx::Expr::Object& Expr::_internal_object() const {
  const ::Mysqlx::Expr::Object* p = object_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Expr::Object*>(
      &::Mysqlx::Expr::_Object_default_instance_);
}
inline const ::Mysqlx::Expr::Object& Expr::object() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.object)
  return _internal_object();
}
inline ::Mysqlx::Expr::Object* Expr::release_object() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Expr.object)
  _has_bits_[0] &= ~0x00000020u;
  ::Mysqlx::Expr::Object* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::Mysqlx::Expr::Object* Expr::_internal_mutable_object() {
  _has_bits_[0] |= 0x00000020u;
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::Object>(GetArenaNoVirtual());
    object_ = p;
  }
  return object_;
}
inline ::Mysqlx::Expr::Object* Expr::mutable_object() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Expr.object)
  return _internal_mutable_object();
}
inline void Expr::set_allocated_object(::Mysqlx::Expr::Object* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Expr.object)
}

// optional .Mysqlx.Expr.Array array = 9;
inline bool Expr::_internal_has_array() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || array_ != nullptr);
  return value;
}
inline bool Expr::has_array() const {
  return _internal_has_array();
}
inline void Expr::clear_array() {
  if (array_ != nullptr) array_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::Mysqlx::Expr::Array& Expr::_internal_array() const {
  const ::Mysqlx::Expr::Array* p = array_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Expr::Array*>(
      &::Mysqlx::Expr::_Array_default_instance_);
}
inline const ::Mysqlx::Expr::Array& Expr::array() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Expr.array)
  return _internal_array();
}
inline ::Mysqlx::Expr::Array* Expr::release_array() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Expr.array)
  _has_bits_[0] &= ~0x00000040u;
  ::Mysqlx::Expr::Array* temp = array_;
  array_ = nullptr;
  return temp;
}
inline ::Mysqlx::Expr::Array* Expr::_internal_mutable_array() {
  _has_bits_[0] |= 0x00000040u;
  if (array_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::Array>(GetArenaNoVirtual());
    array_ = p;
  }
  return array_;
}
inline ::Mysqlx::Expr::Array* Expr::mutable_array() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Expr.array)
  return _internal_mutable_array();
}
inline void Expr::set_allocated_array(::Mysqlx::Expr::Array* array) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete array_;
  }
  if (array) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      array = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, array, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  array_ = array;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Expr.array)
}

// -------------------------------------------------------------------

// Identifier

// required string name = 1;
inline bool Identifier::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Identifier::has_name() const {
  return _internal_has_name();
}
inline void Identifier::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Identifier::name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Identifier.name)
  return _internal_name();
}
inline void Identifier::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.Identifier.name)
}
inline std::string* Identifier::mutable_name() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Identifier.name)
  return _internal_mutable_name();
}
inline const std::string& Identifier::_internal_name() const {
  return name_.GetNoArena();
}
inline void Identifier::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Identifier::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Expr.Identifier.name)
}
inline void Identifier::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.Identifier.name)
}
inline void Identifier::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.Identifier.name)
}
inline std::string* Identifier::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Identifier::release_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Identifier.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Identifier::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Identifier.name)
}

// optional string schema_name = 2;
inline bool Identifier::_internal_has_schema_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Identifier::has_schema_name() const {
  return _internal_has_schema_name();
}
inline void Identifier::clear_schema_name() {
  schema_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Identifier::schema_name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Identifier.schema_name)
  return _internal_schema_name();
}
inline void Identifier::set_schema_name(const std::string& value) {
  _internal_set_schema_name(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.Identifier.schema_name)
}
inline std::string* Identifier::mutable_schema_name() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Identifier.schema_name)
  return _internal_mutable_schema_name();
}
inline const std::string& Identifier::_internal_schema_name() const {
  return schema_name_.GetNoArena();
}
inline void Identifier::_internal_set_schema_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  schema_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Identifier::set_schema_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  schema_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Expr.Identifier.schema_name)
}
inline void Identifier::set_schema_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  schema_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.Identifier.schema_name)
}
inline void Identifier::set_schema_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  schema_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.Identifier.schema_name)
}
inline std::string* Identifier::_internal_mutable_schema_name() {
  _has_bits_[0] |= 0x00000002u;
  return schema_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Identifier::release_schema_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Identifier.schema_name)
  if (!_internal_has_schema_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return schema_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Identifier::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  schema_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), schema_name);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Identifier.schema_name)
}

// -------------------------------------------------------------------

// DocumentPathItem

// required .Mysqlx.Expr.DocumentPathItem.Type type = 1;
inline bool DocumentPathItem::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DocumentPathItem::has_type() const {
  return _internal_has_type();
}
inline void DocumentPathItem::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::Mysqlx::Expr::DocumentPathItem_Type DocumentPathItem::_internal_type() const {
  return static_cast< ::Mysqlx::Expr::DocumentPathItem_Type >(type_);
}
inline ::Mysqlx::Expr::DocumentPathItem_Type DocumentPathItem::type() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.DocumentPathItem.type)
  return _internal_type();
}
inline void DocumentPathItem::_internal_set_type(::Mysqlx::Expr::DocumentPathItem_Type value) {
  assert(::Mysqlx::Expr::DocumentPathItem_Type_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void DocumentPathItem::set_type(::Mysqlx::Expr::DocumentPathItem_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.DocumentPathItem.type)
}

// optional string value = 2;
inline bool DocumentPathItem::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DocumentPathItem::has_value() const {
  return _internal_has_value();
}
inline void DocumentPathItem::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DocumentPathItem::value() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.DocumentPathItem.value)
  return _internal_value();
}
inline void DocumentPathItem::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.DocumentPathItem.value)
}
inline std::string* DocumentPathItem::mutable_value() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.DocumentPathItem.value)
  return _internal_mutable_value();
}
inline const std::string& DocumentPathItem::_internal_value() const {
  return value_.GetNoArena();
}
inline void DocumentPathItem::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void DocumentPathItem::set_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Expr.DocumentPathItem.value)
}
inline void DocumentPathItem::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.DocumentPathItem.value)
}
inline void DocumentPathItem::set_value(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.DocumentPathItem.value)
}
inline std::string* DocumentPathItem::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DocumentPathItem::release_value() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.DocumentPathItem.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return value_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DocumentPathItem::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.DocumentPathItem.value)
}

// optional uint32 index = 3;
inline bool DocumentPathItem::_internal_has_index() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DocumentPathItem::has_index() const {
  return _internal_has_index();
}
inline void DocumentPathItem::clear_index() {
  index_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DocumentPathItem::_internal_index() const {
  return index_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DocumentPathItem::index() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.DocumentPathItem.index)
  return _internal_index();
}
inline void DocumentPathItem::_internal_set_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  index_ = value;
}
inline void DocumentPathItem::set_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.DocumentPathItem.index)
}

// -------------------------------------------------------------------

// ColumnIdentifier

// repeated .Mysqlx.Expr.DocumentPathItem document_path = 1;
inline int ColumnIdentifier::_internal_document_path_size() const {
  return document_path_.size();
}
inline int ColumnIdentifier::document_path_size() const {
  return _internal_document_path_size();
}
inline void ColumnIdentifier::clear_document_path() {
  document_path_.Clear();
}
inline ::Mysqlx::Expr::DocumentPathItem* ColumnIdentifier::mutable_document_path(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.ColumnIdentifier.document_path)
  return document_path_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >*
ColumnIdentifier::mutable_document_path() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Expr.ColumnIdentifier.document_path)
  return &document_path_;
}
inline const ::Mysqlx::Expr::DocumentPathItem& ColumnIdentifier::_internal_document_path(int index) const {
  return document_path_.Get(index);
}
inline const ::Mysqlx::Expr::DocumentPathItem& ColumnIdentifier::document_path(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.ColumnIdentifier.document_path)
  return _internal_document_path(index);
}
inline ::Mysqlx::Expr::DocumentPathItem* ColumnIdentifier::_internal_add_document_path() {
  return document_path_.Add();
}
inline ::Mysqlx::Expr::DocumentPathItem* ColumnIdentifier::add_document_path() {
  // @@protoc_insertion_point(field_add:Mysqlx.Expr.ColumnIdentifier.document_path)
  return _internal_add_document_path();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >&
ColumnIdentifier::document_path() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Expr.ColumnIdentifier.document_path)
  return document_path_;
}

// optional string name = 2;
inline bool ColumnIdentifier::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ColumnIdentifier::has_name() const {
  return _internal_has_name();
}
inline void ColumnIdentifier::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ColumnIdentifier::name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.ColumnIdentifier.name)
  return _internal_name();
}
inline void ColumnIdentifier::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.ColumnIdentifier.name)
}
inline std::string* ColumnIdentifier::mutable_name() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.ColumnIdentifier.name)
  return _internal_mutable_name();
}
inline const std::string& ColumnIdentifier::_internal_name() const {
  return name_.GetNoArena();
}
inline void ColumnIdentifier::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ColumnIdentifier::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Expr.ColumnIdentifier.name)
}
inline void ColumnIdentifier::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.ColumnIdentifier.name)
}
inline void ColumnIdentifier::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.ColumnIdentifier.name)
}
inline std::string* ColumnIdentifier::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ColumnIdentifier::release_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.ColumnIdentifier.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnIdentifier::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.ColumnIdentifier.name)
}

// optional string table_name = 3;
inline bool ColumnIdentifier::_internal_has_table_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ColumnIdentifier::has_table_name() const {
  return _internal_has_table_name();
}
inline void ColumnIdentifier::clear_table_name() {
  table_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ColumnIdentifier::table_name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.ColumnIdentifier.table_name)
  return _internal_table_name();
}
inline void ColumnIdentifier::set_table_name(const std::string& value) {
  _internal_set_table_name(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.ColumnIdentifier.table_name)
}
inline std::string* ColumnIdentifier::mutable_table_name() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.ColumnIdentifier.table_name)
  return _internal_mutable_table_name();
}
inline const std::string& ColumnIdentifier::_internal_table_name() const {
  return table_name_.GetNoArena();
}
inline void ColumnIdentifier::_internal_set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  table_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ColumnIdentifier::set_table_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  table_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Expr.ColumnIdentifier.table_name)
}
inline void ColumnIdentifier::set_table_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  table_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.ColumnIdentifier.table_name)
}
inline void ColumnIdentifier::set_table_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  table_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.ColumnIdentifier.table_name)
}
inline std::string* ColumnIdentifier::_internal_mutable_table_name() {
  _has_bits_[0] |= 0x00000002u;
  return table_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ColumnIdentifier::release_table_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.ColumnIdentifier.table_name)
  if (!_internal_has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return table_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnIdentifier::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  table_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.ColumnIdentifier.table_name)
}

// optional string schema_name = 4;
inline bool ColumnIdentifier::_internal_has_schema_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ColumnIdentifier::has_schema_name() const {
  return _internal_has_schema_name();
}
inline void ColumnIdentifier::clear_schema_name() {
  schema_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ColumnIdentifier::schema_name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.ColumnIdentifier.schema_name)
  return _internal_schema_name();
}
inline void ColumnIdentifier::set_schema_name(const std::string& value) {
  _internal_set_schema_name(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.ColumnIdentifier.schema_name)
}
inline std::string* ColumnIdentifier::mutable_schema_name() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.ColumnIdentifier.schema_name)
  return _internal_mutable_schema_name();
}
inline const std::string& ColumnIdentifier::_internal_schema_name() const {
  return schema_name_.GetNoArena();
}
inline void ColumnIdentifier::_internal_set_schema_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  schema_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ColumnIdentifier::set_schema_name(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  schema_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Expr.ColumnIdentifier.schema_name)
}
inline void ColumnIdentifier::set_schema_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  schema_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.ColumnIdentifier.schema_name)
}
inline void ColumnIdentifier::set_schema_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  schema_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.ColumnIdentifier.schema_name)
}
inline std::string* ColumnIdentifier::_internal_mutable_schema_name() {
  _has_bits_[0] |= 0x00000004u;
  return schema_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ColumnIdentifier::release_schema_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.ColumnIdentifier.schema_name)
  if (!_internal_has_schema_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return schema_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnIdentifier::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  schema_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), schema_name);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.ColumnIdentifier.schema_name)
}

// -------------------------------------------------------------------

// FunctionCall

// required .Mysqlx.Expr.Identifier name = 1;
inline bool FunctionCall::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || name_ != nullptr);
  return value;
}
inline bool FunctionCall::has_name() const {
  return _internal_has_name();
}
inline void FunctionCall::clear_name() {
  if (name_ != nullptr) name_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Mysqlx::Expr::Identifier& FunctionCall::_internal_name() const {
  const ::Mysqlx::Expr::Identifier* p = name_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Expr::Identifier*>(
      &::Mysqlx::Expr::_Identifier_default_instance_);
}
inline const ::Mysqlx::Expr::Identifier& FunctionCall::name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.FunctionCall.name)
  return _internal_name();
}
inline ::Mysqlx::Expr::Identifier* FunctionCall::release_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.FunctionCall.name)
  _has_bits_[0] &= ~0x00000001u;
  ::Mysqlx::Expr::Identifier* temp = name_;
  name_ = nullptr;
  return temp;
}
inline ::Mysqlx::Expr::Identifier* FunctionCall::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  if (name_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::Identifier>(GetArenaNoVirtual());
    name_ = p;
  }
  return name_;
}
inline ::Mysqlx::Expr::Identifier* FunctionCall::mutable_name() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.FunctionCall.name)
  return _internal_mutable_name();
}
inline void FunctionCall::set_allocated_name(::Mysqlx::Expr::Identifier* name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete name_;
  }
  if (name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.FunctionCall.name)
}

// repeated .Mysqlx.Expr.Expr param = 2;
inline int FunctionCall::_internal_param_size() const {
  return param_.size();
}
inline int FunctionCall::param_size() const {
  return _internal_param_size();
}
inline void FunctionCall::clear_param() {
  param_.Clear();
}
inline ::Mysqlx::Expr::Expr* FunctionCall::mutable_param(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.FunctionCall.param)
  return param_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
FunctionCall::mutable_param() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Expr.FunctionCall.param)
  return &param_;
}
inline const ::Mysqlx::Expr::Expr& FunctionCall::_internal_param(int index) const {
  return param_.Get(index);
}
inline const ::Mysqlx::Expr::Expr& FunctionCall::param(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.FunctionCall.param)
  return _internal_param(index);
}
inline ::Mysqlx::Expr::Expr* FunctionCall::_internal_add_param() {
  return param_.Add();
}
inline ::Mysqlx::Expr::Expr* FunctionCall::add_param() {
  // @@protoc_insertion_point(field_add:Mysqlx.Expr.FunctionCall.param)
  return _internal_add_param();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
FunctionCall::param() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Expr.FunctionCall.param)
  return param_;
}

// -------------------------------------------------------------------

// Operator

// required string name = 1;
inline bool Operator::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Operator::has_name() const {
  return _internal_has_name();
}
inline void Operator::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Operator::name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Operator.name)
  return _internal_name();
}
inline void Operator::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.Operator.name)
}
inline std::string* Operator::mutable_name() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Operator.name)
  return _internal_mutable_name();
}
inline const std::string& Operator::_internal_name() const {
  return name_.GetNoArena();
}
inline void Operator::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Operator::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Expr.Operator.name)
}
inline void Operator::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.Operator.name)
}
inline void Operator::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.Operator.name)
}
inline std::string* Operator::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Operator::release_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Operator.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Operator::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Operator.name)
}

// repeated .Mysqlx.Expr.Expr param = 2;
inline int Operator::_internal_param_size() const {
  return param_.size();
}
inline int Operator::param_size() const {
  return _internal_param_size();
}
inline void Operator::clear_param() {
  param_.Clear();
}
inline ::Mysqlx::Expr::Expr* Operator::mutable_param(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Operator.param)
  return param_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
Operator::mutable_param() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Expr.Operator.param)
  return &param_;
}
inline const ::Mysqlx::Expr::Expr& Operator::_internal_param(int index) const {
  return param_.Get(index);
}
inline const ::Mysqlx::Expr::Expr& Operator::param(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Operator.param)
  return _internal_param(index);
}
inline ::Mysqlx::Expr::Expr* Operator::_internal_add_param() {
  return param_.Add();
}
inline ::Mysqlx::Expr::Expr* Operator::add_param() {
  // @@protoc_insertion_point(field_add:Mysqlx.Expr.Operator.param)
  return _internal_add_param();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
Operator::param() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Expr.Operator.param)
  return param_;
}

// -------------------------------------------------------------------

// Object_ObjectField

// required string key = 1;
inline bool Object_ObjectField::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Object_ObjectField::has_key() const {
  return _internal_has_key();
}
inline void Object_ObjectField::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Object_ObjectField::key() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Object.ObjectField.key)
  return _internal_key();
}
inline void Object_ObjectField::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Expr.Object.ObjectField.key)
}
inline std::string* Object_ObjectField::mutable_key() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Object.ObjectField.key)
  return _internal_mutable_key();
}
inline const std::string& Object_ObjectField::_internal_key() const {
  return key_.GetNoArena();
}
inline void Object_ObjectField::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Object_ObjectField::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Expr.Object.ObjectField.key)
}
inline void Object_ObjectField::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Expr.Object.ObjectField.key)
}
inline void Object_ObjectField::set_key(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Expr.Object.ObjectField.key)
}
inline std::string* Object_ObjectField::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Object_ObjectField::release_key() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Object.ObjectField.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Object_ObjectField::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Object.ObjectField.key)
}

// required .Mysqlx.Expr.Expr value = 2;
inline bool Object_ObjectField::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || value_ != nullptr);
  return value;
}
inline bool Object_ObjectField::has_value() const {
  return _internal_has_value();
}
inline void Object_ObjectField::clear_value() {
  if (value_ != nullptr) value_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::Mysqlx::Expr::Expr& Object_ObjectField::_internal_value() const {
  const ::Mysqlx::Expr::Expr* p = value_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Expr::Expr*>(
      &::Mysqlx::Expr::_Expr_default_instance_);
}
inline const ::Mysqlx::Expr::Expr& Object_ObjectField::value() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Object.ObjectField.value)
  return _internal_value();
}
inline ::Mysqlx::Expr::Expr* Object_ObjectField::release_value() {
  // @@protoc_insertion_point(field_release:Mysqlx.Expr.Object.ObjectField.value)
  _has_bits_[0] &= ~0x00000002u;
  ::Mysqlx::Expr::Expr* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::Mysqlx::Expr::Expr* Object_ObjectField::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::Expr>(GetArenaNoVirtual());
    value_ = p;
  }
  return value_;
}
inline ::Mysqlx::Expr::Expr* Object_ObjectField::mutable_value() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Object.ObjectField.value)
  return _internal_mutable_value();
}
inline void Object_ObjectField::set_allocated_value(::Mysqlx::Expr::Expr* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Expr.Object.ObjectField.value)
}

// -------------------------------------------------------------------

// Object

// repeated .Mysqlx.Expr.Object.ObjectField fld = 1;
inline int Object::_internal_fld_size() const {
  return fld_.size();
}
inline int Object::fld_size() const {
  return _internal_fld_size();
}
inline void Object::clear_fld() {
  fld_.Clear();
}
inline ::Mysqlx::Expr::Object_ObjectField* Object::mutable_fld(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Object.fld)
  return fld_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Object_ObjectField >*
Object::mutable_fld() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Expr.Object.fld)
  return &fld_;
}
inline const ::Mysqlx::Expr::Object_ObjectField& Object::_internal_fld(int index) const {
  return fld_.Get(index);
}
inline const ::Mysqlx::Expr::Object_ObjectField& Object::fld(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Object.fld)
  return _internal_fld(index);
}
inline ::Mysqlx::Expr::Object_ObjectField* Object::_internal_add_fld() {
  return fld_.Add();
}
inline ::Mysqlx::Expr::Object_ObjectField* Object::add_fld() {
  // @@protoc_insertion_point(field_add:Mysqlx.Expr.Object.fld)
  return _internal_add_fld();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Object_ObjectField >&
Object::fld() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Expr.Object.fld)
  return fld_;
}

// -------------------------------------------------------------------

// Array

// repeated .Mysqlx.Expr.Expr value = 1;
inline int Array::_internal_value_size() const {
  return value_.size();
}
inline int Array::value_size() const {
  return _internal_value_size();
}
inline void Array::clear_value() {
  value_.Clear();
}
inline ::Mysqlx::Expr::Expr* Array::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Expr.Array.value)
  return value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
Array::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Expr.Array.value)
  return &value_;
}
inline const ::Mysqlx::Expr::Expr& Array::_internal_value(int index) const {
  return value_.Get(index);
}
inline const ::Mysqlx::Expr::Expr& Array::value(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Expr.Array.value)
  return _internal_value(index);
}
inline ::Mysqlx::Expr::Expr* Array::_internal_add_value() {
  return value_.Add();
}
inline ::Mysqlx::Expr::Expr* Array::add_value() {
  // @@protoc_insertion_point(field_add:Mysqlx.Expr.Array.value)
  return _internal_add_value();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
Array::value() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Expr.Array.value)
  return value_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Expr
}  // namespace Mysqlx

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Mysqlx::Expr::Expr_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::Mysqlx::Expr::DocumentPathItem_Type> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mysqlx_5fexpr_2eproto
