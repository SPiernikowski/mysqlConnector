// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mysqlx_crud.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mysqlx_5fcrud_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mysqlx_5fcrud_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "mysqlx_expr.pb.h"
#include "mysqlx_datatypes.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mysqlx_5fcrud_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mysqlx_5fcrud_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace Mysqlx {
namespace Crud {
class Collection;
class CollectionDefaultTypeInternal;
extern CollectionDefaultTypeInternal _Collection_default_instance_;
class Column;
class ColumnDefaultTypeInternal;
extern ColumnDefaultTypeInternal _Column_default_instance_;
class CreateView;
class CreateViewDefaultTypeInternal;
extern CreateViewDefaultTypeInternal _CreateView_default_instance_;
class Delete;
class DeleteDefaultTypeInternal;
extern DeleteDefaultTypeInternal _Delete_default_instance_;
class DropView;
class DropViewDefaultTypeInternal;
extern DropViewDefaultTypeInternal _DropView_default_instance_;
class Find;
class FindDefaultTypeInternal;
extern FindDefaultTypeInternal _Find_default_instance_;
class Insert;
class InsertDefaultTypeInternal;
extern InsertDefaultTypeInternal _Insert_default_instance_;
class Insert_TypedRow;
class Insert_TypedRowDefaultTypeInternal;
extern Insert_TypedRowDefaultTypeInternal _Insert_TypedRow_default_instance_;
class Limit;
class LimitDefaultTypeInternal;
extern LimitDefaultTypeInternal _Limit_default_instance_;
class LimitExpr;
class LimitExprDefaultTypeInternal;
extern LimitExprDefaultTypeInternal _LimitExpr_default_instance_;
class ModifyView;
class ModifyViewDefaultTypeInternal;
extern ModifyViewDefaultTypeInternal _ModifyView_default_instance_;
class Order;
class OrderDefaultTypeInternal;
extern OrderDefaultTypeInternal _Order_default_instance_;
class Projection;
class ProjectionDefaultTypeInternal;
extern ProjectionDefaultTypeInternal _Projection_default_instance_;
class Update;
class UpdateDefaultTypeInternal;
extern UpdateDefaultTypeInternal _Update_default_instance_;
class UpdateOperation;
class UpdateOperationDefaultTypeInternal;
extern UpdateOperationDefaultTypeInternal _UpdateOperation_default_instance_;
}  // namespace Crud
}  // namespace Mysqlx
PROTOBUF_NAMESPACE_OPEN
template<> ::Mysqlx::Crud::Collection* Arena::CreateMaybeMessage<::Mysqlx::Crud::Collection>(Arena*);
template<> ::Mysqlx::Crud::Column* Arena::CreateMaybeMessage<::Mysqlx::Crud::Column>(Arena*);
template<> ::Mysqlx::Crud::CreateView* Arena::CreateMaybeMessage<::Mysqlx::Crud::CreateView>(Arena*);
template<> ::Mysqlx::Crud::Delete* Arena::CreateMaybeMessage<::Mysqlx::Crud::Delete>(Arena*);
template<> ::Mysqlx::Crud::DropView* Arena::CreateMaybeMessage<::Mysqlx::Crud::DropView>(Arena*);
template<> ::Mysqlx::Crud::Find* Arena::CreateMaybeMessage<::Mysqlx::Crud::Find>(Arena*);
template<> ::Mysqlx::Crud::Insert* Arena::CreateMaybeMessage<::Mysqlx::Crud::Insert>(Arena*);
template<> ::Mysqlx::Crud::Insert_TypedRow* Arena::CreateMaybeMessage<::Mysqlx::Crud::Insert_TypedRow>(Arena*);
template<> ::Mysqlx::Crud::Limit* Arena::CreateMaybeMessage<::Mysqlx::Crud::Limit>(Arena*);
template<> ::Mysqlx::Crud::LimitExpr* Arena::CreateMaybeMessage<::Mysqlx::Crud::LimitExpr>(Arena*);
template<> ::Mysqlx::Crud::ModifyView* Arena::CreateMaybeMessage<::Mysqlx::Crud::ModifyView>(Arena*);
template<> ::Mysqlx::Crud::Order* Arena::CreateMaybeMessage<::Mysqlx::Crud::Order>(Arena*);
template<> ::Mysqlx::Crud::Projection* Arena::CreateMaybeMessage<::Mysqlx::Crud::Projection>(Arena*);
template<> ::Mysqlx::Crud::Update* Arena::CreateMaybeMessage<::Mysqlx::Crud::Update>(Arena*);
template<> ::Mysqlx::Crud::UpdateOperation* Arena::CreateMaybeMessage<::Mysqlx::Crud::UpdateOperation>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Mysqlx {
namespace Crud {

enum Order_Direction : int {
  Order_Direction_ASC = 1,
  Order_Direction_DESC = 2
};
bool Order_Direction_IsValid(int value);
constexpr Order_Direction Order_Direction_Direction_MIN = Order_Direction_ASC;
constexpr Order_Direction Order_Direction_Direction_MAX = Order_Direction_DESC;
constexpr int Order_Direction_Direction_ARRAYSIZE = Order_Direction_Direction_MAX + 1;

const std::string& Order_Direction_Name(Order_Direction value);
template<typename T>
inline const std::string& Order_Direction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Order_Direction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Order_Direction_Name.");
  return Order_Direction_Name(static_cast<Order_Direction>(enum_t_value));
}
bool Order_Direction_Parse(
    const std::string& name, Order_Direction* value);
enum UpdateOperation_UpdateType : int {
  UpdateOperation_UpdateType_SET = 1,
  UpdateOperation_UpdateType_ITEM_REMOVE = 2,
  UpdateOperation_UpdateType_ITEM_SET = 3,
  UpdateOperation_UpdateType_ITEM_REPLACE = 4,
  UpdateOperation_UpdateType_ITEM_MERGE = 5,
  UpdateOperation_UpdateType_ARRAY_INSERT = 6,
  UpdateOperation_UpdateType_ARRAY_APPEND = 7,
  UpdateOperation_UpdateType_MERGE_PATCH = 8
};
bool UpdateOperation_UpdateType_IsValid(int value);
constexpr UpdateOperation_UpdateType UpdateOperation_UpdateType_UpdateType_MIN = UpdateOperation_UpdateType_SET;
constexpr UpdateOperation_UpdateType UpdateOperation_UpdateType_UpdateType_MAX = UpdateOperation_UpdateType_MERGE_PATCH;
constexpr int UpdateOperation_UpdateType_UpdateType_ARRAYSIZE = UpdateOperation_UpdateType_UpdateType_MAX + 1;

const std::string& UpdateOperation_UpdateType_Name(UpdateOperation_UpdateType value);
template<typename T>
inline const std::string& UpdateOperation_UpdateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UpdateOperation_UpdateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UpdateOperation_UpdateType_Name.");
  return UpdateOperation_UpdateType_Name(static_cast<UpdateOperation_UpdateType>(enum_t_value));
}
bool UpdateOperation_UpdateType_Parse(
    const std::string& name, UpdateOperation_UpdateType* value);
enum Find_RowLock : int {
  Find_RowLock_SHARED_LOCK = 1,
  Find_RowLock_EXCLUSIVE_LOCK = 2
};
bool Find_RowLock_IsValid(int value);
constexpr Find_RowLock Find_RowLock_RowLock_MIN = Find_RowLock_SHARED_LOCK;
constexpr Find_RowLock Find_RowLock_RowLock_MAX = Find_RowLock_EXCLUSIVE_LOCK;
constexpr int Find_RowLock_RowLock_ARRAYSIZE = Find_RowLock_RowLock_MAX + 1;

const std::string& Find_RowLock_Name(Find_RowLock value);
template<typename T>
inline const std::string& Find_RowLock_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Find_RowLock>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Find_RowLock_Name.");
  return Find_RowLock_Name(static_cast<Find_RowLock>(enum_t_value));
}
bool Find_RowLock_Parse(
    const std::string& name, Find_RowLock* value);
enum Find_RowLockOptions : int {
  Find_RowLockOptions_NOWAIT = 1,
  Find_RowLockOptions_SKIP_LOCKED = 2
};
bool Find_RowLockOptions_IsValid(int value);
constexpr Find_RowLockOptions Find_RowLockOptions_RowLockOptions_MIN = Find_RowLockOptions_NOWAIT;
constexpr Find_RowLockOptions Find_RowLockOptions_RowLockOptions_MAX = Find_RowLockOptions_SKIP_LOCKED;
constexpr int Find_RowLockOptions_RowLockOptions_ARRAYSIZE = Find_RowLockOptions_RowLockOptions_MAX + 1;

const std::string& Find_RowLockOptions_Name(Find_RowLockOptions value);
template<typename T>
inline const std::string& Find_RowLockOptions_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Find_RowLockOptions>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Find_RowLockOptions_Name.");
  return Find_RowLockOptions_Name(static_cast<Find_RowLockOptions>(enum_t_value));
}
bool Find_RowLockOptions_Parse(
    const std::string& name, Find_RowLockOptions* value);
enum DataModel : int {
  DOCUMENT = 1,
  TABLE = 2
};
bool DataModel_IsValid(int value);
constexpr DataModel DataModel_MIN = DOCUMENT;
constexpr DataModel DataModel_MAX = TABLE;
constexpr int DataModel_ARRAYSIZE = DataModel_MAX + 1;

const std::string& DataModel_Name(DataModel value);
template<typename T>
inline const std::string& DataModel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataModel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataModel_Name.");
  return DataModel_Name(static_cast<DataModel>(enum_t_value));
}
bool DataModel_Parse(
    const std::string& name, DataModel* value);
enum ViewAlgorithm : int {
  UNDEFINED = 1,
  MERGE = 2,
  TEMPTABLE = 3
};
bool ViewAlgorithm_IsValid(int value);
constexpr ViewAlgorithm ViewAlgorithm_MIN = UNDEFINED;
constexpr ViewAlgorithm ViewAlgorithm_MAX = TEMPTABLE;
constexpr int ViewAlgorithm_ARRAYSIZE = ViewAlgorithm_MAX + 1;

const std::string& ViewAlgorithm_Name(ViewAlgorithm value);
template<typename T>
inline const std::string& ViewAlgorithm_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ViewAlgorithm>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ViewAlgorithm_Name.");
  return ViewAlgorithm_Name(static_cast<ViewAlgorithm>(enum_t_value));
}
bool ViewAlgorithm_Parse(
    const std::string& name, ViewAlgorithm* value);
enum ViewSqlSecurity : int {
  INVOKER = 1,
  DEFINER = 2
};
bool ViewSqlSecurity_IsValid(int value);
constexpr ViewSqlSecurity ViewSqlSecurity_MIN = INVOKER;
constexpr ViewSqlSecurity ViewSqlSecurity_MAX = DEFINER;
constexpr int ViewSqlSecurity_ARRAYSIZE = ViewSqlSecurity_MAX + 1;

const std::string& ViewSqlSecurity_Name(ViewSqlSecurity value);
template<typename T>
inline const std::string& ViewSqlSecurity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ViewSqlSecurity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ViewSqlSecurity_Name.");
  return ViewSqlSecurity_Name(static_cast<ViewSqlSecurity>(enum_t_value));
}
bool ViewSqlSecurity_Parse(
    const std::string& name, ViewSqlSecurity* value);
enum ViewCheckOption : int {
  LOCAL = 1,
  CASCADED = 2
};
bool ViewCheckOption_IsValid(int value);
constexpr ViewCheckOption ViewCheckOption_MIN = LOCAL;
constexpr ViewCheckOption ViewCheckOption_MAX = CASCADED;
constexpr int ViewCheckOption_ARRAYSIZE = ViewCheckOption_MAX + 1;

const std::string& ViewCheckOption_Name(ViewCheckOption value);
template<typename T>
inline const std::string& ViewCheckOption_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ViewCheckOption>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ViewCheckOption_Name.");
  return ViewCheckOption_Name(static_cast<ViewCheckOption>(enum_t_value));
}
bool ViewCheckOption_Parse(
    const std::string& name, ViewCheckOption* value);
// ===================================================================

class Column :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Column) */ {
 public:
  Column();
  virtual ~Column();

  Column(const Column& from);
  Column(Column&& from) noexcept
    : Column() {
    *this = ::std::move(from);
  }

  inline Column& operator=(const Column& from) {
    CopyFrom(from);
    return *this;
  }
  inline Column& operator=(Column&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Column& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Column* internal_default_instance() {
    return reinterpret_cast<const Column*>(
               &_Column_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Column& a, Column& b) {
    a.Swap(&b);
  }
  inline void Swap(Column* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Column* New() const final {
    return CreateMaybeMessage<Column>(nullptr);
  }

  Column* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Column>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Column& from);
  void MergeFrom(const Column& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Column* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mysqlx.Crud.Column";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentPathFieldNumber = 3,
    kNameFieldNumber = 1,
    kAliasFieldNumber = 2,
  };
  // repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
  int document_path_size() const;
  private:
  int _internal_document_path_size() const;
  public:
  void clear_document_path();
  ::Mysqlx::Expr::DocumentPathItem* mutable_document_path(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >*
      mutable_document_path();
  private:
  const ::Mysqlx::Expr::DocumentPathItem& _internal_document_path(int index) const;
  ::Mysqlx::Expr::DocumentPathItem* _internal_add_document_path();
  public:
  const ::Mysqlx::Expr::DocumentPathItem& document_path(int index) const;
  ::Mysqlx::Expr::DocumentPathItem* add_document_path();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >&
      document_path() const;

  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string alias = 2;
  bool has_alias() const;
  private:
  bool _internal_has_alias() const;
  public:
  void clear_alias();
  const std::string& alias() const;
  void set_alias(const std::string& value);
  void set_alias(std::string&& value);
  void set_alias(const char* value);
  void set_alias(const char* value, size_t size);
  std::string* mutable_alias();
  std::string* release_alias();
  void set_allocated_alias(std::string* alias);
  private:
  const std::string& _internal_alias() const;
  void _internal_set_alias(const std::string& value);
  std::string* _internal_mutable_alias();
  public:

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Column)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem > document_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr alias_;
  friend struct ::TableStruct_mysqlx_5fcrud_2eproto;
};
// -------------------------------------------------------------------

class Projection :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Projection) */ {
 public:
  Projection();
  virtual ~Projection();

  Projection(const Projection& from);
  Projection(Projection&& from) noexcept
    : Projection() {
    *this = ::std::move(from);
  }

  inline Projection& operator=(const Projection& from) {
    CopyFrom(from);
    return *this;
  }
  inline Projection& operator=(Projection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Projection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Projection* internal_default_instance() {
    return reinterpret_cast<const Projection*>(
               &_Projection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Projection& a, Projection& b) {
    a.Swap(&b);
  }
  inline void Swap(Projection* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Projection* New() const final {
    return CreateMaybeMessage<Projection>(nullptr);
  }

  Projection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Projection>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Projection& from);
  void MergeFrom(const Projection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Projection* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mysqlx.Crud.Projection";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAliasFieldNumber = 2,
    kSourceFieldNumber = 1,
  };
  // optional string alias = 2;
  bool has_alias() const;
  private:
  bool _internal_has_alias() const;
  public:
  void clear_alias();
  const std::string& alias() const;
  void set_alias(const std::string& value);
  void set_alias(std::string&& value);
  void set_alias(const char* value);
  void set_alias(const char* value, size_t size);
  std::string* mutable_alias();
  std::string* release_alias();
  void set_allocated_alias(std::string* alias);
  private:
  const std::string& _internal_alias() const;
  void _internal_set_alias(const std::string& value);
  std::string* _internal_mutable_alias();
  public:

  // required .Mysqlx.Expr.Expr source = 1;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::Mysqlx::Expr::Expr& source() const;
  ::Mysqlx::Expr::Expr* release_source();
  ::Mysqlx::Expr::Expr* mutable_source();
  void set_allocated_source(::Mysqlx::Expr::Expr* source);
  private:
  const ::Mysqlx::Expr::Expr& _internal_source() const;
  ::Mysqlx::Expr::Expr* _internal_mutable_source();
  public:

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Projection)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr alias_;
  ::Mysqlx::Expr::Expr* source_;
  friend struct ::TableStruct_mysqlx_5fcrud_2eproto;
};
// -------------------------------------------------------------------

class Collection :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Collection) */ {
 public:
  Collection();
  virtual ~Collection();

  Collection(const Collection& from);
  Collection(Collection&& from) noexcept
    : Collection() {
    *this = ::std::move(from);
  }

  inline Collection& operator=(const Collection& from) {
    CopyFrom(from);
    return *this;
  }
  inline Collection& operator=(Collection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Collection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Collection* internal_default_instance() {
    return reinterpret_cast<const Collection*>(
               &_Collection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Collection& a, Collection& b) {
    a.Swap(&b);
  }
  inline void Swap(Collection* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Collection* New() const final {
    return CreateMaybeMessage<Collection>(nullptr);
  }

  Collection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Collection>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Collection& from);
  void MergeFrom(const Collection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Collection* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mysqlx.Crud.Collection";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSchemaFieldNumber = 2,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string schema = 2;
  bool has_schema() const;
  private:
  bool _internal_has_schema() const;
  public:
  void clear_schema();
  const std::string& schema() const;
  void set_schema(const std::string& value);
  void set_schema(std::string&& value);
  void set_schema(const char* value);
  void set_schema(const char* value, size_t size);
  std::string* mutable_schema();
  std::string* release_schema();
  void set_allocated_schema(std::string* schema);
  private:
  const std::string& _internal_schema() const;
  void _internal_set_schema(const std::string& value);
  std::string* _internal_mutable_schema();
  public:

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Collection)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_;
  friend struct ::TableStruct_mysqlx_5fcrud_2eproto;
};
// -------------------------------------------------------------------

class Limit :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Limit) */ {
 public:
  Limit();
  virtual ~Limit();

  Limit(const Limit& from);
  Limit(Limit&& from) noexcept
    : Limit() {
    *this = ::std::move(from);
  }

  inline Limit& operator=(const Limit& from) {
    CopyFrom(from);
    return *this;
  }
  inline Limit& operator=(Limit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Limit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Limit* internal_default_instance() {
    return reinterpret_cast<const Limit*>(
               &_Limit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Limit& a, Limit& b) {
    a.Swap(&b);
  }
  inline void Swap(Limit* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Limit* New() const final {
    return CreateMaybeMessage<Limit>(nullptr);
  }

  Limit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Limit>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Limit& from);
  void MergeFrom(const Limit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Limit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mysqlx.Crud.Limit";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowCountFieldNumber = 1,
    kOffsetFieldNumber = 2,
  };
  // required uint64 row_count = 1;
  bool has_row_count() const;
  private:
  bool _internal_has_row_count() const;
  public:
  void clear_row_count();
  ::PROTOBUF_NAMESPACE_ID::uint64 row_count() const;
  void set_row_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_row_count() const;
  void _internal_set_row_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 offset = 2;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::uint64 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_offset() const;
  void _internal_set_offset(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Limit)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 row_count_;
  ::PROTOBUF_NAMESPACE_ID::uint64 offset_;
  friend struct ::TableStruct_mysqlx_5fcrud_2eproto;
};
// -------------------------------------------------------------------

class LimitExpr :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.LimitExpr) */ {
 public:
  LimitExpr();
  virtual ~LimitExpr();

  LimitExpr(const LimitExpr& from);
  LimitExpr(LimitExpr&& from) noexcept
    : LimitExpr() {
    *this = ::std::move(from);
  }

  inline LimitExpr& operator=(const LimitExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline LimitExpr& operator=(LimitExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const LimitExpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LimitExpr* internal_default_instance() {
    return reinterpret_cast<const LimitExpr*>(
               &_LimitExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LimitExpr& a, LimitExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(LimitExpr* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LimitExpr* New() const final {
    return CreateMaybeMessage<LimitExpr>(nullptr);
  }

  LimitExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LimitExpr>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const LimitExpr& from);
  void MergeFrom(const LimitExpr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LimitExpr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mysqlx.Crud.LimitExpr";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowCountFieldNumber = 1,
    kOffsetFieldNumber = 2,
  };
  // required .Mysqlx.Expr.Expr row_count = 1;
  bool has_row_count() const;
  private:
  bool _internal_has_row_count() const;
  public:
  void clear_row_count();
  const ::Mysqlx::Expr::Expr& row_count() const;
  ::Mysqlx::Expr::Expr* release_row_count();
  ::Mysqlx::Expr::Expr* mutable_row_count();
  void set_allocated_row_count(::Mysqlx::Expr::Expr* row_count);
  private:
  const ::Mysqlx::Expr::Expr& _internal_row_count() const;
  ::Mysqlx::Expr::Expr* _internal_mutable_row_count();
  public:

  // optional .Mysqlx.Expr.Expr offset = 2;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  const ::Mysqlx::Expr::Expr& offset() const;
  ::Mysqlx::Expr::Expr* release_offset();
  ::Mysqlx::Expr::Expr* mutable_offset();
  void set_allocated_offset(::Mysqlx::Expr::Expr* offset);
  private:
  const ::Mysqlx::Expr::Expr& _internal_offset() const;
  ::Mysqlx::Expr::Expr* _internal_mutable_offset();
  public:

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.LimitExpr)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::Mysqlx::Expr::Expr* row_count_;
  ::Mysqlx::Expr::Expr* offset_;
  friend struct ::TableStruct_mysqlx_5fcrud_2eproto;
};
// -------------------------------------------------------------------

class Order :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Order) */ {
 public:
  Order();
  virtual ~Order();

  Order(const Order& from);
  Order(Order&& from) noexcept
    : Order() {
    *this = ::std::move(from);
  }

  inline Order& operator=(const Order& from) {
    CopyFrom(from);
    return *this;
  }
  inline Order& operator=(Order&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Order& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Order* internal_default_instance() {
    return reinterpret_cast<const Order*>(
               &_Order_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Order& a, Order& b) {
    a.Swap(&b);
  }
  inline void Swap(Order* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Order* New() const final {
    return CreateMaybeMessage<Order>(nullptr);
  }

  Order* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Order>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Order& from);
  void MergeFrom(const Order& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Order* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mysqlx.Crud.Order";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Order_Direction Direction;
  static constexpr Direction ASC =
    Order_Direction_ASC;
  static constexpr Direction DESC =
    Order_Direction_DESC;
  static inline bool Direction_IsValid(int value) {
    return Order_Direction_IsValid(value);
  }
  static constexpr Direction Direction_MIN =
    Order_Direction_Direction_MIN;
  static constexpr Direction Direction_MAX =
    Order_Direction_Direction_MAX;
  static constexpr int Direction_ARRAYSIZE =
    Order_Direction_Direction_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Direction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Direction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Direction_Name.");
    return Order_Direction_Name(enum_t_value);
  }
  static inline bool Direction_Parse(const std::string& name,
      Direction* value) {
    return Order_Direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kExprFieldNumber = 1,
    kDirectionFieldNumber = 2,
  };
  // required .Mysqlx.Expr.Expr expr = 1;
  bool has_expr() const;
  private:
  bool _internal_has_expr() const;
  public:
  void clear_expr();
  const ::Mysqlx::Expr::Expr& expr() const;
  ::Mysqlx::Expr::Expr* release_expr();
  ::Mysqlx::Expr::Expr* mutable_expr();
  void set_allocated_expr(::Mysqlx::Expr::Expr* expr);
  private:
  const ::Mysqlx::Expr::Expr& _internal_expr() const;
  ::Mysqlx::Expr::Expr* _internal_mutable_expr();
  public:

  // optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  ::Mysqlx::Crud::Order_Direction direction() const;
  void set_direction(::Mysqlx::Crud::Order_Direction value);
  private:
  ::Mysqlx::Crud::Order_Direction _internal_direction() const;
  void _internal_set_direction(::Mysqlx::Crud::Order_Direction value);
  public:

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Order)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::Mysqlx::Expr::Expr* expr_;
  int direction_;
  friend struct ::TableStruct_mysqlx_5fcrud_2eproto;
};
// -------------------------------------------------------------------

class UpdateOperation :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.UpdateOperation) */ {
 public:
  UpdateOperation();
  virtual ~UpdateOperation();

  UpdateOperation(const UpdateOperation& from);
  UpdateOperation(UpdateOperation&& from) noexcept
    : UpdateOperation() {
    *this = ::std::move(from);
  }

  inline UpdateOperation& operator=(const UpdateOperation& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateOperation& operator=(UpdateOperation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const UpdateOperation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateOperation* internal_default_instance() {
    return reinterpret_cast<const UpdateOperation*>(
               &_UpdateOperation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UpdateOperation& a, UpdateOperation& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateOperation* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateOperation* New() const final {
    return CreateMaybeMessage<UpdateOperation>(nullptr);
  }

  UpdateOperation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateOperation>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const UpdateOperation& from);
  void MergeFrom(const UpdateOperation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UpdateOperation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mysqlx.Crud.UpdateOperation";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef UpdateOperation_UpdateType UpdateType;
  static constexpr UpdateType SET =
    UpdateOperation_UpdateType_SET;
  static constexpr UpdateType ITEM_REMOVE =
    UpdateOperation_UpdateType_ITEM_REMOVE;
  static constexpr UpdateType ITEM_SET =
    UpdateOperation_UpdateType_ITEM_SET;
  static constexpr UpdateType ITEM_REPLACE =
    UpdateOperation_UpdateType_ITEM_REPLACE;
  static constexpr UpdateType ITEM_MERGE =
    UpdateOperation_UpdateType_ITEM_MERGE;
  static constexpr UpdateType ARRAY_INSERT =
    UpdateOperation_UpdateType_ARRAY_INSERT;
  static constexpr UpdateType ARRAY_APPEND =
    UpdateOperation_UpdateType_ARRAY_APPEND;
  static constexpr UpdateType MERGE_PATCH =
    UpdateOperation_UpdateType_MERGE_PATCH;
  static inline bool UpdateType_IsValid(int value) {
    return UpdateOperation_UpdateType_IsValid(value);
  }
  static constexpr UpdateType UpdateType_MIN =
    UpdateOperation_UpdateType_UpdateType_MIN;
  static constexpr UpdateType UpdateType_MAX =
    UpdateOperation_UpdateType_UpdateType_MAX;
  static constexpr int UpdateType_ARRAYSIZE =
    UpdateOperation_UpdateType_UpdateType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& UpdateType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UpdateType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UpdateType_Name.");
    return UpdateOperation_UpdateType_Name(enum_t_value);
  }
  static inline bool UpdateType_Parse(const std::string& name,
      UpdateType* value) {
    return UpdateOperation_UpdateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSourceFieldNumber = 1,
    kValueFieldNumber = 3,
    kOperationFieldNumber = 2,
  };
  // required .Mysqlx.Expr.ColumnIdentifier source = 1;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::Mysqlx::Expr::ColumnIdentifier& source() const;
  ::Mysqlx::Expr::ColumnIdentifier* release_source();
  ::Mysqlx::Expr::ColumnIdentifier* mutable_source();
  void set_allocated_source(::Mysqlx::Expr::ColumnIdentifier* source);
  private:
  const ::Mysqlx::Expr::ColumnIdentifier& _internal_source() const;
  ::Mysqlx::Expr::ColumnIdentifier* _internal_mutable_source();
  public:

  // optional .Mysqlx.Expr.Expr value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::Mysqlx::Expr::Expr& value() const;
  ::Mysqlx::Expr::Expr* release_value();
  ::Mysqlx::Expr::Expr* mutable_value();
  void set_allocated_value(::Mysqlx::Expr::Expr* value);
  private:
  const ::Mysqlx::Expr::Expr& _internal_value() const;
  ::Mysqlx::Expr::Expr* _internal_mutable_value();
  public:

  // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
  bool has_operation() const;
  private:
  bool _internal_has_operation() const;
  public:
  void clear_operation();
  ::Mysqlx::Crud::UpdateOperation_UpdateType operation() const;
  void set_operation(::Mysqlx::Crud::UpdateOperation_UpdateType value);
  private:
  ::Mysqlx::Crud::UpdateOperation_UpdateType _internal_operation() const;
  void _internal_set_operation(::Mysqlx::Crud::UpdateOperation_UpdateType value);
  public:

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.UpdateOperation)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::Mysqlx::Expr::ColumnIdentifier* source_;
  ::Mysqlx::Expr::Expr* value_;
  int operation_;
  friend struct ::TableStruct_mysqlx_5fcrud_2eproto;
};
// -------------------------------------------------------------------

class Find :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Find) */ {
 public:
  Find();
  virtual ~Find();

  Find(const Find& from);
  Find(Find&& from) noexcept
    : Find() {
    *this = ::std::move(from);
  }

  inline Find& operator=(const Find& from) {
    CopyFrom(from);
    return *this;
  }
  inline Find& operator=(Find&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Find& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Find* internal_default_instance() {
    return reinterpret_cast<const Find*>(
               &_Find_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Find& a, Find& b) {
    a.Swap(&b);
  }
  inline void Swap(Find* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Find* New() const final {
    return CreateMaybeMessage<Find>(nullptr);
  }

  Find* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Find>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Find& from);
  void MergeFrom(const Find& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Find* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mysqlx.Crud.Find";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Find_RowLock RowLock;
  static constexpr RowLock SHARED_LOCK =
    Find_RowLock_SHARED_LOCK;
  static constexpr RowLock EXCLUSIVE_LOCK =
    Find_RowLock_EXCLUSIVE_LOCK;
  static inline bool RowLock_IsValid(int value) {
    return Find_RowLock_IsValid(value);
  }
  static constexpr RowLock RowLock_MIN =
    Find_RowLock_RowLock_MIN;
  static constexpr RowLock RowLock_MAX =
    Find_RowLock_RowLock_MAX;
  static constexpr int RowLock_ARRAYSIZE =
    Find_RowLock_RowLock_ARRAYSIZE;
  template<typename T>
  static inline const std::string& RowLock_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RowLock>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RowLock_Name.");
    return Find_RowLock_Name(enum_t_value);
  }
  static inline bool RowLock_Parse(const std::string& name,
      RowLock* value) {
    return Find_RowLock_Parse(name, value);
  }

  typedef Find_RowLockOptions RowLockOptions;
  static constexpr RowLockOptions NOWAIT =
    Find_RowLockOptions_NOWAIT;
  static constexpr RowLockOptions SKIP_LOCKED =
    Find_RowLockOptions_SKIP_LOCKED;
  static inline bool RowLockOptions_IsValid(int value) {
    return Find_RowLockOptions_IsValid(value);
  }
  static constexpr RowLockOptions RowLockOptions_MIN =
    Find_RowLockOptions_RowLockOptions_MIN;
  static constexpr RowLockOptions RowLockOptions_MAX =
    Find_RowLockOptions_RowLockOptions_MAX;
  static constexpr int RowLockOptions_ARRAYSIZE =
    Find_RowLockOptions_RowLockOptions_ARRAYSIZE;
  template<typename T>
  static inline const std::string& RowLockOptions_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RowLockOptions>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RowLockOptions_Name.");
    return Find_RowLockOptions_Name(enum_t_value);
  }
  static inline bool RowLockOptions_Parse(const std::string& name,
      RowLockOptions* value) {
    return Find_RowLockOptions_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kProjectionFieldNumber = 4,
    kOrderFieldNumber = 7,
    kGroupingFieldNumber = 8,
    kArgsFieldNumber = 11,
    kCollectionFieldNumber = 2,
    kCriteriaFieldNumber = 5,
    kLimitFieldNumber = 6,
    kGroupingCriteriaFieldNumber = 9,
    kLimitExprFieldNumber = 14,
    kLockingOptionsFieldNumber = 13,
    kDataModelFieldNumber = 3,
    kLockingFieldNumber = 12,
  };
  // repeated .Mysqlx.Crud.Projection projection = 4;
  int projection_size() const;
  private:
  int _internal_projection_size() const;
  public:
  void clear_projection();
  ::Mysqlx::Crud::Projection* mutable_projection(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Projection >*
      mutable_projection();
  private:
  const ::Mysqlx::Crud::Projection& _internal_projection(int index) const;
  ::Mysqlx::Crud::Projection* _internal_add_projection();
  public:
  const ::Mysqlx::Crud::Projection& projection(int index) const;
  ::Mysqlx::Crud::Projection* add_projection();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Projection >&
      projection() const;

  // repeated .Mysqlx.Crud.Order order = 7;
  int order_size() const;
  private:
  int _internal_order_size() const;
  public:
  void clear_order();
  ::Mysqlx::Crud::Order* mutable_order(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Order >*
      mutable_order();
  private:
  const ::Mysqlx::Crud::Order& _internal_order(int index) const;
  ::Mysqlx::Crud::Order* _internal_add_order();
  public:
  const ::Mysqlx::Crud::Order& order(int index) const;
  ::Mysqlx::Crud::Order* add_order();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Order >&
      order() const;

  // repeated .Mysqlx.Expr.Expr grouping = 8;
  int grouping_size() const;
  private:
  int _internal_grouping_size() const;
  public:
  void clear_grouping();
  ::Mysqlx::Expr::Expr* mutable_grouping(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
      mutable_grouping();
  private:
  const ::Mysqlx::Expr::Expr& _internal_grouping(int index) const;
  ::Mysqlx::Expr::Expr* _internal_add_grouping();
  public:
  const ::Mysqlx::Expr::Expr& grouping(int index) const;
  ::Mysqlx::Expr::Expr* add_grouping();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
      grouping() const;

  // repeated .Mysqlx.Datatypes.Scalar args = 11;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  ::Mysqlx::Datatypes::Scalar* mutable_args(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
      mutable_args();
  private:
  const ::Mysqlx::Datatypes::Scalar& _internal_args(int index) const;
  ::Mysqlx::Datatypes::Scalar* _internal_add_args();
  public:
  const ::Mysqlx::Datatypes::Scalar& args(int index) const;
  ::Mysqlx::Datatypes::Scalar* add_args();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
      args() const;

  // required .Mysqlx.Crud.Collection collection = 2;
  bool has_collection() const;
  private:
  bool _internal_has_collection() const;
  public:
  void clear_collection();
  const ::Mysqlx::Crud::Collection& collection() const;
  ::Mysqlx::Crud::Collection* release_collection();
  ::Mysqlx::Crud::Collection* mutable_collection();
  void set_allocated_collection(::Mysqlx::Crud::Collection* collection);
  private:
  const ::Mysqlx::Crud::Collection& _internal_collection() const;
  ::Mysqlx::Crud::Collection* _internal_mutable_collection();
  public:

  // optional .Mysqlx.Expr.Expr criteria = 5;
  bool has_criteria() const;
  private:
  bool _internal_has_criteria() const;
  public:
  void clear_criteria();
  const ::Mysqlx::Expr::Expr& criteria() const;
  ::Mysqlx::Expr::Expr* release_criteria();
  ::Mysqlx::Expr::Expr* mutable_criteria();
  void set_allocated_criteria(::Mysqlx::Expr::Expr* criteria);
  private:
  const ::Mysqlx::Expr::Expr& _internal_criteria() const;
  ::Mysqlx::Expr::Expr* _internal_mutable_criteria();
  public:

  // optional .Mysqlx.Crud.Limit limit = 6;
  bool has_limit() const;
  private:
  bool _internal_has_limit() const;
  public:
  void clear_limit();
  const ::Mysqlx::Crud::Limit& limit() const;
  ::Mysqlx::Crud::Limit* release_limit();
  ::Mysqlx::Crud::Limit* mutable_limit();
  void set_allocated_limit(::Mysqlx::Crud::Limit* limit);
  private:
  const ::Mysqlx::Crud::Limit& _internal_limit() const;
  ::Mysqlx::Crud::Limit* _internal_mutable_limit();
  public:

  // optional .Mysqlx.Expr.Expr grouping_criteria = 9;
  bool has_grouping_criteria() const;
  private:
  bool _internal_has_grouping_criteria() const;
  public:
  void clear_grouping_criteria();
  const ::Mysqlx::Expr::Expr& grouping_criteria() const;
  ::Mysqlx::Expr::Expr* release_grouping_criteria();
  ::Mysqlx::Expr::Expr* mutable_grouping_criteria();
  void set_allocated_grouping_criteria(::Mysqlx::Expr::Expr* grouping_criteria);
  private:
  const ::Mysqlx::Expr::Expr& _internal_grouping_criteria() const;
  ::Mysqlx::Expr::Expr* _internal_mutable_grouping_criteria();
  public:

  // optional .Mysqlx.Crud.LimitExpr limit_expr = 14;
  bool has_limit_expr() const;
  private:
  bool _internal_has_limit_expr() const;
  public:
  void clear_limit_expr();
  const ::Mysqlx::Crud::LimitExpr& limit_expr() const;
  ::Mysqlx::Crud::LimitExpr* release_limit_expr();
  ::Mysqlx::Crud::LimitExpr* mutable_limit_expr();
  void set_allocated_limit_expr(::Mysqlx::Crud::LimitExpr* limit_expr);
  private:
  const ::Mysqlx::Crud::LimitExpr& _internal_limit_expr() const;
  ::Mysqlx::Crud::LimitExpr* _internal_mutable_limit_expr();
  public:

  // optional .Mysqlx.Crud.Find.RowLockOptions locking_options = 13;
  bool has_locking_options() const;
  private:
  bool _internal_has_locking_options() const;
  public:
  void clear_locking_options();
  ::Mysqlx::Crud::Find_RowLockOptions locking_options() const;
  void set_locking_options(::Mysqlx::Crud::Find_RowLockOptions value);
  private:
  ::Mysqlx::Crud::Find_RowLockOptions _internal_locking_options() const;
  void _internal_set_locking_options(::Mysqlx::Crud::Find_RowLockOptions value);
  public:

  // optional .Mysqlx.Crud.DataModel data_model = 3;
  bool has_data_model() const;
  private:
  bool _internal_has_data_model() const;
  public:
  void clear_data_model();
  ::Mysqlx::Crud::DataModel data_model() const;
  void set_data_model(::Mysqlx::Crud::DataModel value);
  private:
  ::Mysqlx::Crud::DataModel _internal_data_model() const;
  void _internal_set_data_model(::Mysqlx::Crud::DataModel value);
  public:

  // optional .Mysqlx.Crud.Find.RowLock locking = 12;
  bool has_locking() const;
  private:
  bool _internal_has_locking() const;
  public:
  void clear_locking();
  ::Mysqlx::Crud::Find_RowLock locking() const;
  void set_locking(::Mysqlx::Crud::Find_RowLock value);
  private:
  ::Mysqlx::Crud::Find_RowLock _internal_locking() const;
  void _internal_set_locking(::Mysqlx::Crud::Find_RowLock value);
  public:

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Find)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Projection > projection_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Order > order_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Expr > grouping_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar > args_;
  ::Mysqlx::Crud::Collection* collection_;
  ::Mysqlx::Expr::Expr* criteria_;
  ::Mysqlx::Crud::Limit* limit_;
  ::Mysqlx::Expr::Expr* grouping_criteria_;
  ::Mysqlx::Crud::LimitExpr* limit_expr_;
  int locking_options_;
  int data_model_;
  int locking_;
  friend struct ::TableStruct_mysqlx_5fcrud_2eproto;
};
// -------------------------------------------------------------------

class Insert_TypedRow :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Insert.TypedRow) */ {
 public:
  Insert_TypedRow();
  virtual ~Insert_TypedRow();

  Insert_TypedRow(const Insert_TypedRow& from);
  Insert_TypedRow(Insert_TypedRow&& from) noexcept
    : Insert_TypedRow() {
    *this = ::std::move(from);
  }

  inline Insert_TypedRow& operator=(const Insert_TypedRow& from) {
    CopyFrom(from);
    return *this;
  }
  inline Insert_TypedRow& operator=(Insert_TypedRow&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Insert_TypedRow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Insert_TypedRow* internal_default_instance() {
    return reinterpret_cast<const Insert_TypedRow*>(
               &_Insert_TypedRow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Insert_TypedRow& a, Insert_TypedRow& b) {
    a.Swap(&b);
  }
  inline void Swap(Insert_TypedRow* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Insert_TypedRow* New() const final {
    return CreateMaybeMessage<Insert_TypedRow>(nullptr);
  }

  Insert_TypedRow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Insert_TypedRow>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Insert_TypedRow& from);
  void MergeFrom(const Insert_TypedRow& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Insert_TypedRow* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mysqlx.Crud.Insert.TypedRow";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 1,
  };
  // repeated .Mysqlx.Expr.Expr field = 1;
  int field_size() const;
  private:
  int _internal_field_size() const;
  public:
  void clear_field();
  ::Mysqlx::Expr::Expr* mutable_field(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
      mutable_field();
  private:
  const ::Mysqlx::Expr::Expr& _internal_field(int index) const;
  ::Mysqlx::Expr::Expr* _internal_add_field();
  public:
  const ::Mysqlx::Expr::Expr& field(int index) const;
  ::Mysqlx::Expr::Expr* add_field();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
      field() const;

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Insert.TypedRow)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Expr > field_;
  friend struct ::TableStruct_mysqlx_5fcrud_2eproto;
};
// -------------------------------------------------------------------

class Insert :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Insert) */ {
 public:
  Insert();
  virtual ~Insert();

  Insert(const Insert& from);
  Insert(Insert&& from) noexcept
    : Insert() {
    *this = ::std::move(from);
  }

  inline Insert& operator=(const Insert& from) {
    CopyFrom(from);
    return *this;
  }
  inline Insert& operator=(Insert&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Insert& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Insert* internal_default_instance() {
    return reinterpret_cast<const Insert*>(
               &_Insert_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Insert& a, Insert& b) {
    a.Swap(&b);
  }
  inline void Swap(Insert* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Insert* New() const final {
    return CreateMaybeMessage<Insert>(nullptr);
  }

  Insert* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Insert>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Insert& from);
  void MergeFrom(const Insert& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Insert* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mysqlx.Crud.Insert";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Insert_TypedRow TypedRow;

  // accessors -------------------------------------------------------

  enum : int {
    kProjectionFieldNumber = 3,
    kRowFieldNumber = 4,
    kArgsFieldNumber = 5,
    kCollectionFieldNumber = 1,
    kUpsertFieldNumber = 6,
    kDataModelFieldNumber = 2,
  };
  // repeated .Mysqlx.Crud.Column projection = 3;
  int projection_size() const;
  private:
  int _internal_projection_size() const;
  public:
  void clear_projection();
  ::Mysqlx::Crud::Column* mutable_projection(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Column >*
      mutable_projection();
  private:
  const ::Mysqlx::Crud::Column& _internal_projection(int index) const;
  ::Mysqlx::Crud::Column* _internal_add_projection();
  public:
  const ::Mysqlx::Crud::Column& projection(int index) const;
  ::Mysqlx::Crud::Column* add_projection();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Column >&
      projection() const;

  // repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
  int row_size() const;
  private:
  int _internal_row_size() const;
  public:
  void clear_row();
  ::Mysqlx::Crud::Insert_TypedRow* mutable_row(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Insert_TypedRow >*
      mutable_row();
  private:
  const ::Mysqlx::Crud::Insert_TypedRow& _internal_row(int index) const;
  ::Mysqlx::Crud::Insert_TypedRow* _internal_add_row();
  public:
  const ::Mysqlx::Crud::Insert_TypedRow& row(int index) const;
  ::Mysqlx::Crud::Insert_TypedRow* add_row();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Insert_TypedRow >&
      row() const;

  // repeated .Mysqlx.Datatypes.Scalar args = 5;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  ::Mysqlx::Datatypes::Scalar* mutable_args(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
      mutable_args();
  private:
  const ::Mysqlx::Datatypes::Scalar& _internal_args(int index) const;
  ::Mysqlx::Datatypes::Scalar* _internal_add_args();
  public:
  const ::Mysqlx::Datatypes::Scalar& args(int index) const;
  ::Mysqlx::Datatypes::Scalar* add_args();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
      args() const;

  // required .Mysqlx.Crud.Collection collection = 1;
  bool has_collection() const;
  private:
  bool _internal_has_collection() const;
  public:
  void clear_collection();
  const ::Mysqlx::Crud::Collection& collection() const;
  ::Mysqlx::Crud::Collection* release_collection();
  ::Mysqlx::Crud::Collection* mutable_collection();
  void set_allocated_collection(::Mysqlx::Crud::Collection* collection);
  private:
  const ::Mysqlx::Crud::Collection& _internal_collection() const;
  ::Mysqlx::Crud::Collection* _internal_mutable_collection();
  public:

  // optional bool upsert = 6 [default = false];
  bool has_upsert() const;
  private:
  bool _internal_has_upsert() const;
  public:
  void clear_upsert();
  bool upsert() const;
  void set_upsert(bool value);
  private:
  bool _internal_upsert() const;
  void _internal_set_upsert(bool value);
  public:

  // optional .Mysqlx.Crud.DataModel data_model = 2;
  bool has_data_model() const;
  private:
  bool _internal_has_data_model() const;
  public:
  void clear_data_model();
  ::Mysqlx::Crud::DataModel data_model() const;
  void set_data_model(::Mysqlx::Crud::DataModel value);
  private:
  ::Mysqlx::Crud::DataModel _internal_data_model() const;
  void _internal_set_data_model(::Mysqlx::Crud::DataModel value);
  public:

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Insert)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Column > projection_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Insert_TypedRow > row_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar > args_;
  ::Mysqlx::Crud::Collection* collection_;
  bool upsert_;
  int data_model_;
  friend struct ::TableStruct_mysqlx_5fcrud_2eproto;
};
// -------------------------------------------------------------------

class Update :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Update) */ {
 public:
  Update();
  virtual ~Update();

  Update(const Update& from);
  Update(Update&& from) noexcept
    : Update() {
    *this = ::std::move(from);
  }

  inline Update& operator=(const Update& from) {
    CopyFrom(from);
    return *this;
  }
  inline Update& operator=(Update&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Update& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Update* internal_default_instance() {
    return reinterpret_cast<const Update*>(
               &_Update_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Update& a, Update& b) {
    a.Swap(&b);
  }
  inline void Swap(Update* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Update* New() const final {
    return CreateMaybeMessage<Update>(nullptr);
  }

  Update* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Update>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Update& from);
  void MergeFrom(const Update& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Update* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mysqlx.Crud.Update";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderFieldNumber = 6,
    kOperationFieldNumber = 7,
    kArgsFieldNumber = 8,
    kCollectionFieldNumber = 2,
    kCriteriaFieldNumber = 4,
    kLimitFieldNumber = 5,
    kLimitExprFieldNumber = 9,
    kDataModelFieldNumber = 3,
  };
  // repeated .Mysqlx.Crud.Order order = 6;
  int order_size() const;
  private:
  int _internal_order_size() const;
  public:
  void clear_order();
  ::Mysqlx::Crud::Order* mutable_order(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Order >*
      mutable_order();
  private:
  const ::Mysqlx::Crud::Order& _internal_order(int index) const;
  ::Mysqlx::Crud::Order* _internal_add_order();
  public:
  const ::Mysqlx::Crud::Order& order(int index) const;
  ::Mysqlx::Crud::Order* add_order();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Order >&
      order() const;

  // repeated .Mysqlx.Crud.UpdateOperation operation = 7;
  int operation_size() const;
  private:
  int _internal_operation_size() const;
  public:
  void clear_operation();
  ::Mysqlx::Crud::UpdateOperation* mutable_operation(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::UpdateOperation >*
      mutable_operation();
  private:
  const ::Mysqlx::Crud::UpdateOperation& _internal_operation(int index) const;
  ::Mysqlx::Crud::UpdateOperation* _internal_add_operation();
  public:
  const ::Mysqlx::Crud::UpdateOperation& operation(int index) const;
  ::Mysqlx::Crud::UpdateOperation* add_operation();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::UpdateOperation >&
      operation() const;

  // repeated .Mysqlx.Datatypes.Scalar args = 8;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  ::Mysqlx::Datatypes::Scalar* mutable_args(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
      mutable_args();
  private:
  const ::Mysqlx::Datatypes::Scalar& _internal_args(int index) const;
  ::Mysqlx::Datatypes::Scalar* _internal_add_args();
  public:
  const ::Mysqlx::Datatypes::Scalar& args(int index) const;
  ::Mysqlx::Datatypes::Scalar* add_args();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
      args() const;

  // required .Mysqlx.Crud.Collection collection = 2;
  bool has_collection() const;
  private:
  bool _internal_has_collection() const;
  public:
  void clear_collection();
  const ::Mysqlx::Crud::Collection& collection() const;
  ::Mysqlx::Crud::Collection* release_collection();
  ::Mysqlx::Crud::Collection* mutable_collection();
  void set_allocated_collection(::Mysqlx::Crud::Collection* collection);
  private:
  const ::Mysqlx::Crud::Collection& _internal_collection() const;
  ::Mysqlx::Crud::Collection* _internal_mutable_collection();
  public:

  // optional .Mysqlx.Expr.Expr criteria = 4;
  bool has_criteria() const;
  private:
  bool _internal_has_criteria() const;
  public:
  void clear_criteria();
  const ::Mysqlx::Expr::Expr& criteria() const;
  ::Mysqlx::Expr::Expr* release_criteria();
  ::Mysqlx::Expr::Expr* mutable_criteria();
  void set_allocated_criteria(::Mysqlx::Expr::Expr* criteria);
  private:
  const ::Mysqlx::Expr::Expr& _internal_criteria() const;
  ::Mysqlx::Expr::Expr* _internal_mutable_criteria();
  public:

  // optional .Mysqlx.Crud.Limit limit = 5;
  bool has_limit() const;
  private:
  bool _internal_has_limit() const;
  public:
  void clear_limit();
  const ::Mysqlx::Crud::Limit& limit() const;
  ::Mysqlx::Crud::Limit* release_limit();
  ::Mysqlx::Crud::Limit* mutable_limit();
  void set_allocated_limit(::Mysqlx::Crud::Limit* limit);
  private:
  const ::Mysqlx::Crud::Limit& _internal_limit() const;
  ::Mysqlx::Crud::Limit* _internal_mutable_limit();
  public:

  // optional .Mysqlx.Crud.LimitExpr limit_expr = 9;
  bool has_limit_expr() const;
  private:
  bool _internal_has_limit_expr() const;
  public:
  void clear_limit_expr();
  const ::Mysqlx::Crud::LimitExpr& limit_expr() const;
  ::Mysqlx::Crud::LimitExpr* release_limit_expr();
  ::Mysqlx::Crud::LimitExpr* mutable_limit_expr();
  void set_allocated_limit_expr(::Mysqlx::Crud::LimitExpr* limit_expr);
  private:
  const ::Mysqlx::Crud::LimitExpr& _internal_limit_expr() const;
  ::Mysqlx::Crud::LimitExpr* _internal_mutable_limit_expr();
  public:

  // optional .Mysqlx.Crud.DataModel data_model = 3;
  bool has_data_model() const;
  private:
  bool _internal_has_data_model() const;
  public:
  void clear_data_model();
  ::Mysqlx::Crud::DataModel data_model() const;
  void set_data_model(::Mysqlx::Crud::DataModel value);
  private:
  ::Mysqlx::Crud::DataModel _internal_data_model() const;
  void _internal_set_data_model(::Mysqlx::Crud::DataModel value);
  public:

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Update)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Order > order_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::UpdateOperation > operation_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar > args_;
  ::Mysqlx::Crud::Collection* collection_;
  ::Mysqlx::Expr::Expr* criteria_;
  ::Mysqlx::Crud::Limit* limit_;
  ::Mysqlx::Crud::LimitExpr* limit_expr_;
  int data_model_;
  friend struct ::TableStruct_mysqlx_5fcrud_2eproto;
};
// -------------------------------------------------------------------

class Delete :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.Delete) */ {
 public:
  Delete();
  virtual ~Delete();

  Delete(const Delete& from);
  Delete(Delete&& from) noexcept
    : Delete() {
    *this = ::std::move(from);
  }

  inline Delete& operator=(const Delete& from) {
    CopyFrom(from);
    return *this;
  }
  inline Delete& operator=(Delete&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Delete& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Delete* internal_default_instance() {
    return reinterpret_cast<const Delete*>(
               &_Delete_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Delete& a, Delete& b) {
    a.Swap(&b);
  }
  inline void Swap(Delete* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Delete* New() const final {
    return CreateMaybeMessage<Delete>(nullptr);
  }

  Delete* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Delete>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Delete& from);
  void MergeFrom(const Delete& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Delete* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mysqlx.Crud.Delete";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderFieldNumber = 5,
    kArgsFieldNumber = 6,
    kCollectionFieldNumber = 1,
    kCriteriaFieldNumber = 3,
    kLimitFieldNumber = 4,
    kLimitExprFieldNumber = 7,
    kDataModelFieldNumber = 2,
  };
  // repeated .Mysqlx.Crud.Order order = 5;
  int order_size() const;
  private:
  int _internal_order_size() const;
  public:
  void clear_order();
  ::Mysqlx::Crud::Order* mutable_order(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Order >*
      mutable_order();
  private:
  const ::Mysqlx::Crud::Order& _internal_order(int index) const;
  ::Mysqlx::Crud::Order* _internal_add_order();
  public:
  const ::Mysqlx::Crud::Order& order(int index) const;
  ::Mysqlx::Crud::Order* add_order();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Order >&
      order() const;

  // repeated .Mysqlx.Datatypes.Scalar args = 6;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  ::Mysqlx::Datatypes::Scalar* mutable_args(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
      mutable_args();
  private:
  const ::Mysqlx::Datatypes::Scalar& _internal_args(int index) const;
  ::Mysqlx::Datatypes::Scalar* _internal_add_args();
  public:
  const ::Mysqlx::Datatypes::Scalar& args(int index) const;
  ::Mysqlx::Datatypes::Scalar* add_args();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
      args() const;

  // required .Mysqlx.Crud.Collection collection = 1;
  bool has_collection() const;
  private:
  bool _internal_has_collection() const;
  public:
  void clear_collection();
  const ::Mysqlx::Crud::Collection& collection() const;
  ::Mysqlx::Crud::Collection* release_collection();
  ::Mysqlx::Crud::Collection* mutable_collection();
  void set_allocated_collection(::Mysqlx::Crud::Collection* collection);
  private:
  const ::Mysqlx::Crud::Collection& _internal_collection() const;
  ::Mysqlx::Crud::Collection* _internal_mutable_collection();
  public:

  // optional .Mysqlx.Expr.Expr criteria = 3;
  bool has_criteria() const;
  private:
  bool _internal_has_criteria() const;
  public:
  void clear_criteria();
  const ::Mysqlx::Expr::Expr& criteria() const;
  ::Mysqlx::Expr::Expr* release_criteria();
  ::Mysqlx::Expr::Expr* mutable_criteria();
  void set_allocated_criteria(::Mysqlx::Expr::Expr* criteria);
  private:
  const ::Mysqlx::Expr::Expr& _internal_criteria() const;
  ::Mysqlx::Expr::Expr* _internal_mutable_criteria();
  public:

  // optional .Mysqlx.Crud.Limit limit = 4;
  bool has_limit() const;
  private:
  bool _internal_has_limit() const;
  public:
  void clear_limit();
  const ::Mysqlx::Crud::Limit& limit() const;
  ::Mysqlx::Crud::Limit* release_limit();
  ::Mysqlx::Crud::Limit* mutable_limit();
  void set_allocated_limit(::Mysqlx::Crud::Limit* limit);
  private:
  const ::Mysqlx::Crud::Limit& _internal_limit() const;
  ::Mysqlx::Crud::Limit* _internal_mutable_limit();
  public:

  // optional .Mysqlx.Crud.LimitExpr limit_expr = 7;
  bool has_limit_expr() const;
  private:
  bool _internal_has_limit_expr() const;
  public:
  void clear_limit_expr();
  const ::Mysqlx::Crud::LimitExpr& limit_expr() const;
  ::Mysqlx::Crud::LimitExpr* release_limit_expr();
  ::Mysqlx::Crud::LimitExpr* mutable_limit_expr();
  void set_allocated_limit_expr(::Mysqlx::Crud::LimitExpr* limit_expr);
  private:
  const ::Mysqlx::Crud::LimitExpr& _internal_limit_expr() const;
  ::Mysqlx::Crud::LimitExpr* _internal_mutable_limit_expr();
  public:

  // optional .Mysqlx.Crud.DataModel data_model = 2;
  bool has_data_model() const;
  private:
  bool _internal_has_data_model() const;
  public:
  void clear_data_model();
  ::Mysqlx::Crud::DataModel data_model() const;
  void set_data_model(::Mysqlx::Crud::DataModel value);
  private:
  ::Mysqlx::Crud::DataModel _internal_data_model() const;
  void _internal_set_data_model(::Mysqlx::Crud::DataModel value);
  public:

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.Delete)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Order > order_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar > args_;
  ::Mysqlx::Crud::Collection* collection_;
  ::Mysqlx::Expr::Expr* criteria_;
  ::Mysqlx::Crud::Limit* limit_;
  ::Mysqlx::Crud::LimitExpr* limit_expr_;
  int data_model_;
  friend struct ::TableStruct_mysqlx_5fcrud_2eproto;
};
// -------------------------------------------------------------------

class CreateView :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.CreateView) */ {
 public:
  CreateView();
  virtual ~CreateView();

  CreateView(const CreateView& from);
  CreateView(CreateView&& from) noexcept
    : CreateView() {
    *this = ::std::move(from);
  }

  inline CreateView& operator=(const CreateView& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateView& operator=(CreateView&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CreateView& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateView* internal_default_instance() {
    return reinterpret_cast<const CreateView*>(
               &_CreateView_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CreateView& a, CreateView& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateView* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateView* New() const final {
    return CreateMaybeMessage<CreateView>(nullptr);
  }

  CreateView* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateView>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const CreateView& from);
  void MergeFrom(const CreateView& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CreateView* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mysqlx.Crud.CreateView";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnFieldNumber = 6,
    kDefinerFieldNumber = 2,
    kCollectionFieldNumber = 1,
    kStmtFieldNumber = 7,
    kReplaceExistingFieldNumber = 8,
    kCheckFieldNumber = 5,
    kAlgorithmFieldNumber = 3,
    kSecurityFieldNumber = 4,
  };
  // repeated string column = 6;
  int column_size() const;
  private:
  int _internal_column_size() const;
  public:
  void clear_column();
  const std::string& column(int index) const;
  std::string* mutable_column(int index);
  void set_column(int index, const std::string& value);
  void set_column(int index, std::string&& value);
  void set_column(int index, const char* value);
  void set_column(int index, const char* value, size_t size);
  std::string* add_column();
  void add_column(const std::string& value);
  void add_column(std::string&& value);
  void add_column(const char* value);
  void add_column(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& column() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_column();
  private:
  const std::string& _internal_column(int index) const;
  std::string* _internal_add_column();
  public:

  // optional string definer = 2;
  bool has_definer() const;
  private:
  bool _internal_has_definer() const;
  public:
  void clear_definer();
  const std::string& definer() const;
  void set_definer(const std::string& value);
  void set_definer(std::string&& value);
  void set_definer(const char* value);
  void set_definer(const char* value, size_t size);
  std::string* mutable_definer();
  std::string* release_definer();
  void set_allocated_definer(std::string* definer);
  private:
  const std::string& _internal_definer() const;
  void _internal_set_definer(const std::string& value);
  std::string* _internal_mutable_definer();
  public:

  // required .Mysqlx.Crud.Collection collection = 1;
  bool has_collection() const;
  private:
  bool _internal_has_collection() const;
  public:
  void clear_collection();
  const ::Mysqlx::Crud::Collection& collection() const;
  ::Mysqlx::Crud::Collection* release_collection();
  ::Mysqlx::Crud::Collection* mutable_collection();
  void set_allocated_collection(::Mysqlx::Crud::Collection* collection);
  private:
  const ::Mysqlx::Crud::Collection& _internal_collection() const;
  ::Mysqlx::Crud::Collection* _internal_mutable_collection();
  public:

  // required .Mysqlx.Crud.Find stmt = 7;
  bool has_stmt() const;
  private:
  bool _internal_has_stmt() const;
  public:
  void clear_stmt();
  const ::Mysqlx::Crud::Find& stmt() const;
  ::Mysqlx::Crud::Find* release_stmt();
  ::Mysqlx::Crud::Find* mutable_stmt();
  void set_allocated_stmt(::Mysqlx::Crud::Find* stmt);
  private:
  const ::Mysqlx::Crud::Find& _internal_stmt() const;
  ::Mysqlx::Crud::Find* _internal_mutable_stmt();
  public:

  // optional bool replace_existing = 8 [default = false];
  bool has_replace_existing() const;
  private:
  bool _internal_has_replace_existing() const;
  public:
  void clear_replace_existing();
  bool replace_existing() const;
  void set_replace_existing(bool value);
  private:
  bool _internal_replace_existing() const;
  void _internal_set_replace_existing(bool value);
  public:

  // optional .Mysqlx.Crud.ViewCheckOption check = 5;
  bool has_check() const;
  private:
  bool _internal_has_check() const;
  public:
  void clear_check();
  ::Mysqlx::Crud::ViewCheckOption check() const;
  void set_check(::Mysqlx::Crud::ViewCheckOption value);
  private:
  ::Mysqlx::Crud::ViewCheckOption _internal_check() const;
  void _internal_set_check(::Mysqlx::Crud::ViewCheckOption value);
  public:

  // optional .Mysqlx.Crud.ViewAlgorithm algorithm = 3 [default = UNDEFINED];
  bool has_algorithm() const;
  private:
  bool _internal_has_algorithm() const;
  public:
  void clear_algorithm();
  ::Mysqlx::Crud::ViewAlgorithm algorithm() const;
  void set_algorithm(::Mysqlx::Crud::ViewAlgorithm value);
  private:
  ::Mysqlx::Crud::ViewAlgorithm _internal_algorithm() const;
  void _internal_set_algorithm(::Mysqlx::Crud::ViewAlgorithm value);
  public:

  // optional .Mysqlx.Crud.ViewSqlSecurity security = 4 [default = DEFINER];
  bool has_security() const;
  private:
  bool _internal_has_security() const;
  public:
  void clear_security();
  ::Mysqlx::Crud::ViewSqlSecurity security() const;
  void set_security(::Mysqlx::Crud::ViewSqlSecurity value);
  private:
  ::Mysqlx::Crud::ViewSqlSecurity _internal_security() const;
  void _internal_set_security(::Mysqlx::Crud::ViewSqlSecurity value);
  public:

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.CreateView)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> column_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr definer_;
  ::Mysqlx::Crud::Collection* collection_;
  ::Mysqlx::Crud::Find* stmt_;
  bool replace_existing_;
  int check_;
  int algorithm_;
  int security_;
  friend struct ::TableStruct_mysqlx_5fcrud_2eproto;
};
// -------------------------------------------------------------------

class ModifyView :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.ModifyView) */ {
 public:
  ModifyView();
  virtual ~ModifyView();

  ModifyView(const ModifyView& from);
  ModifyView(ModifyView&& from) noexcept
    : ModifyView() {
    *this = ::std::move(from);
  }

  inline ModifyView& operator=(const ModifyView& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModifyView& operator=(ModifyView&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ModifyView& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModifyView* internal_default_instance() {
    return reinterpret_cast<const ModifyView*>(
               &_ModifyView_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ModifyView& a, ModifyView& b) {
    a.Swap(&b);
  }
  inline void Swap(ModifyView* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModifyView* New() const final {
    return CreateMaybeMessage<ModifyView>(nullptr);
  }

  ModifyView* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModifyView>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ModifyView& from);
  void MergeFrom(const ModifyView& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ModifyView* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mysqlx.Crud.ModifyView";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnFieldNumber = 6,
    kDefinerFieldNumber = 2,
    kCollectionFieldNumber = 1,
    kStmtFieldNumber = 7,
    kCheckFieldNumber = 5,
    kAlgorithmFieldNumber = 3,
    kSecurityFieldNumber = 4,
  };
  // repeated string column = 6;
  int column_size() const;
  private:
  int _internal_column_size() const;
  public:
  void clear_column();
  const std::string& column(int index) const;
  std::string* mutable_column(int index);
  void set_column(int index, const std::string& value);
  void set_column(int index, std::string&& value);
  void set_column(int index, const char* value);
  void set_column(int index, const char* value, size_t size);
  std::string* add_column();
  void add_column(const std::string& value);
  void add_column(std::string&& value);
  void add_column(const char* value);
  void add_column(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& column() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_column();
  private:
  const std::string& _internal_column(int index) const;
  std::string* _internal_add_column();
  public:

  // optional string definer = 2;
  bool has_definer() const;
  private:
  bool _internal_has_definer() const;
  public:
  void clear_definer();
  const std::string& definer() const;
  void set_definer(const std::string& value);
  void set_definer(std::string&& value);
  void set_definer(const char* value);
  void set_definer(const char* value, size_t size);
  std::string* mutable_definer();
  std::string* release_definer();
  void set_allocated_definer(std::string* definer);
  private:
  const std::string& _internal_definer() const;
  void _internal_set_definer(const std::string& value);
  std::string* _internal_mutable_definer();
  public:

  // required .Mysqlx.Crud.Collection collection = 1;
  bool has_collection() const;
  private:
  bool _internal_has_collection() const;
  public:
  void clear_collection();
  const ::Mysqlx::Crud::Collection& collection() const;
  ::Mysqlx::Crud::Collection* release_collection();
  ::Mysqlx::Crud::Collection* mutable_collection();
  void set_allocated_collection(::Mysqlx::Crud::Collection* collection);
  private:
  const ::Mysqlx::Crud::Collection& _internal_collection() const;
  ::Mysqlx::Crud::Collection* _internal_mutable_collection();
  public:

  // optional .Mysqlx.Crud.Find stmt = 7;
  bool has_stmt() const;
  private:
  bool _internal_has_stmt() const;
  public:
  void clear_stmt();
  const ::Mysqlx::Crud::Find& stmt() const;
  ::Mysqlx::Crud::Find* release_stmt();
  ::Mysqlx::Crud::Find* mutable_stmt();
  void set_allocated_stmt(::Mysqlx::Crud::Find* stmt);
  private:
  const ::Mysqlx::Crud::Find& _internal_stmt() const;
  ::Mysqlx::Crud::Find* _internal_mutable_stmt();
  public:

  // optional .Mysqlx.Crud.ViewCheckOption check = 5;
  bool has_check() const;
  private:
  bool _internal_has_check() const;
  public:
  void clear_check();
  ::Mysqlx::Crud::ViewCheckOption check() const;
  void set_check(::Mysqlx::Crud::ViewCheckOption value);
  private:
  ::Mysqlx::Crud::ViewCheckOption _internal_check() const;
  void _internal_set_check(::Mysqlx::Crud::ViewCheckOption value);
  public:

  // optional .Mysqlx.Crud.ViewAlgorithm algorithm = 3;
  bool has_algorithm() const;
  private:
  bool _internal_has_algorithm() const;
  public:
  void clear_algorithm();
  ::Mysqlx::Crud::ViewAlgorithm algorithm() const;
  void set_algorithm(::Mysqlx::Crud::ViewAlgorithm value);
  private:
  ::Mysqlx::Crud::ViewAlgorithm _internal_algorithm() const;
  void _internal_set_algorithm(::Mysqlx::Crud::ViewAlgorithm value);
  public:

  // optional .Mysqlx.Crud.ViewSqlSecurity security = 4;
  bool has_security() const;
  private:
  bool _internal_has_security() const;
  public:
  void clear_security();
  ::Mysqlx::Crud::ViewSqlSecurity security() const;
  void set_security(::Mysqlx::Crud::ViewSqlSecurity value);
  private:
  ::Mysqlx::Crud::ViewSqlSecurity _internal_security() const;
  void _internal_set_security(::Mysqlx::Crud::ViewSqlSecurity value);
  public:

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.ModifyView)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> column_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr definer_;
  ::Mysqlx::Crud::Collection* collection_;
  ::Mysqlx::Crud::Find* stmt_;
  int check_;
  int algorithm_;
  int security_;
  friend struct ::TableStruct_mysqlx_5fcrud_2eproto;
};
// -------------------------------------------------------------------

class DropView :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Mysqlx.Crud.DropView) */ {
 public:
  DropView();
  virtual ~DropView();

  DropView(const DropView& from);
  DropView(DropView&& from) noexcept
    : DropView() {
    *this = ::std::move(from);
  }

  inline DropView& operator=(const DropView& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropView& operator=(DropView&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DropView& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DropView* internal_default_instance() {
    return reinterpret_cast<const DropView*>(
               &_DropView_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(DropView& a, DropView& b) {
    a.Swap(&b);
  }
  inline void Swap(DropView* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DropView* New() const final {
    return CreateMaybeMessage<DropView>(nullptr);
  }

  DropView* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DropView>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DropView& from);
  void MergeFrom(const DropView& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DropView* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Mysqlx.Crud.DropView";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCollectionFieldNumber = 1,
    kIfExistsFieldNumber = 2,
  };
  // required .Mysqlx.Crud.Collection collection = 1;
  bool has_collection() const;
  private:
  bool _internal_has_collection() const;
  public:
  void clear_collection();
  const ::Mysqlx::Crud::Collection& collection() const;
  ::Mysqlx::Crud::Collection* release_collection();
  ::Mysqlx::Crud::Collection* mutable_collection();
  void set_allocated_collection(::Mysqlx::Crud::Collection* collection);
  private:
  const ::Mysqlx::Crud::Collection& _internal_collection() const;
  ::Mysqlx::Crud::Collection* _internal_mutable_collection();
  public:

  // optional bool if_exists = 2 [default = false];
  bool has_if_exists() const;
  private:
  bool _internal_has_if_exists() const;
  public:
  void clear_if_exists();
  bool if_exists() const;
  void set_if_exists(bool value);
  private:
  bool _internal_if_exists() const;
  void _internal_set_if_exists(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Mysqlx.Crud.DropView)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::Mysqlx::Crud::Collection* collection_;
  bool if_exists_;
  friend struct ::TableStruct_mysqlx_5fcrud_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Column

// optional string name = 1;
inline bool Column::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Column::has_name() const {
  return _internal_has_name();
}
inline void Column::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Column::name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Column.name)
  return _internal_name();
}
inline void Column::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Column.name)
}
inline std::string* Column::mutable_name() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Column.name)
  return _internal_mutable_name();
}
inline const std::string& Column::_internal_name() const {
  return name_.GetNoArena();
}
inline void Column::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Column::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Crud.Column.name)
}
inline void Column::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.Column.name)
}
inline void Column::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.Column.name)
}
inline std::string* Column::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Column::release_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Column.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Column::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Column.name)
}

// optional string alias = 2;
inline bool Column::_internal_has_alias() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Column::has_alias() const {
  return _internal_has_alias();
}
inline void Column::clear_alias() {
  alias_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Column::alias() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Column.alias)
  return _internal_alias();
}
inline void Column::set_alias(const std::string& value) {
  _internal_set_alias(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Column.alias)
}
inline std::string* Column::mutable_alias() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Column.alias)
  return _internal_mutable_alias();
}
inline const std::string& Column::_internal_alias() const {
  return alias_.GetNoArena();
}
inline void Column::_internal_set_alias(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  alias_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Column::set_alias(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  alias_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Crud.Column.alias)
}
inline void Column::set_alias(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  alias_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.Column.alias)
}
inline void Column::set_alias(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  alias_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.Column.alias)
}
inline std::string* Column::_internal_mutable_alias() {
  _has_bits_[0] |= 0x00000002u;
  return alias_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Column::release_alias() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Column.alias)
  if (!_internal_has_alias()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return alias_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Column::set_allocated_alias(std::string* alias) {
  if (alias != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  alias_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), alias);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Column.alias)
}

// repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
inline int Column::_internal_document_path_size() const {
  return document_path_.size();
}
inline int Column::document_path_size() const {
  return _internal_document_path_size();
}
inline ::Mysqlx::Expr::DocumentPathItem* Column::mutable_document_path(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Column.document_path)
  return document_path_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >*
Column::mutable_document_path() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Column.document_path)
  return &document_path_;
}
inline const ::Mysqlx::Expr::DocumentPathItem& Column::_internal_document_path(int index) const {
  return document_path_.Get(index);
}
inline const ::Mysqlx::Expr::DocumentPathItem& Column::document_path(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Column.document_path)
  return _internal_document_path(index);
}
inline ::Mysqlx::Expr::DocumentPathItem* Column::_internal_add_document_path() {
  return document_path_.Add();
}
inline ::Mysqlx::Expr::DocumentPathItem* Column::add_document_path() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Column.document_path)
  return _internal_add_document_path();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::DocumentPathItem >&
Column::document_path() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Column.document_path)
  return document_path_;
}

// -------------------------------------------------------------------

// Projection

// required .Mysqlx.Expr.Expr source = 1;
inline bool Projection::_internal_has_source() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || source_ != nullptr);
  return value;
}
inline bool Projection::has_source() const {
  return _internal_has_source();
}
inline const ::Mysqlx::Expr::Expr& Projection::_internal_source() const {
  const ::Mysqlx::Expr::Expr* p = source_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Expr::Expr*>(
      &::Mysqlx::Expr::_Expr_default_instance_);
}
inline const ::Mysqlx::Expr::Expr& Projection::source() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Projection.source)
  return _internal_source();
}
inline ::Mysqlx::Expr::Expr* Projection::release_source() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Projection.source)
  _has_bits_[0] &= ~0x00000002u;
  ::Mysqlx::Expr::Expr* temp = source_;
  source_ = nullptr;
  return temp;
}
inline ::Mysqlx::Expr::Expr* Projection::_internal_mutable_source() {
  _has_bits_[0] |= 0x00000002u;
  if (source_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::Expr>(GetArenaNoVirtual());
    source_ = p;
  }
  return source_;
}
inline ::Mysqlx::Expr::Expr* Projection::mutable_source() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Projection.source)
  return _internal_mutable_source();
}
inline void Projection::set_allocated_source(::Mysqlx::Expr::Expr* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_);
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Projection.source)
}

// optional string alias = 2;
inline bool Projection::_internal_has_alias() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Projection::has_alias() const {
  return _internal_has_alias();
}
inline void Projection::clear_alias() {
  alias_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Projection::alias() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Projection.alias)
  return _internal_alias();
}
inline void Projection::set_alias(const std::string& value) {
  _internal_set_alias(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Projection.alias)
}
inline std::string* Projection::mutable_alias() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Projection.alias)
  return _internal_mutable_alias();
}
inline const std::string& Projection::_internal_alias() const {
  return alias_.GetNoArena();
}
inline void Projection::_internal_set_alias(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  alias_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Projection::set_alias(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  alias_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Crud.Projection.alias)
}
inline void Projection::set_alias(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  alias_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.Projection.alias)
}
inline void Projection::set_alias(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  alias_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.Projection.alias)
}
inline std::string* Projection::_internal_mutable_alias() {
  _has_bits_[0] |= 0x00000001u;
  return alias_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Projection::release_alias() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Projection.alias)
  if (!_internal_has_alias()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return alias_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Projection::set_allocated_alias(std::string* alias) {
  if (alias != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  alias_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), alias);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Projection.alias)
}

// -------------------------------------------------------------------

// Collection

// required string name = 1;
inline bool Collection::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Collection::has_name() const {
  return _internal_has_name();
}
inline void Collection::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Collection::name() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Collection.name)
  return _internal_name();
}
inline void Collection::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Collection.name)
}
inline std::string* Collection::mutable_name() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Collection.name)
  return _internal_mutable_name();
}
inline const std::string& Collection::_internal_name() const {
  return name_.GetNoArena();
}
inline void Collection::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Collection::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Crud.Collection.name)
}
inline void Collection::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.Collection.name)
}
inline void Collection::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.Collection.name)
}
inline std::string* Collection::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Collection::release_name() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Collection.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Collection::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Collection.name)
}

// optional string schema = 2;
inline bool Collection::_internal_has_schema() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Collection::has_schema() const {
  return _internal_has_schema();
}
inline void Collection::clear_schema() {
  schema_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Collection::schema() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Collection.schema)
  return _internal_schema();
}
inline void Collection::set_schema(const std::string& value) {
  _internal_set_schema(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Collection.schema)
}
inline std::string* Collection::mutable_schema() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Collection.schema)
  return _internal_mutable_schema();
}
inline const std::string& Collection::_internal_schema() const {
  return schema_.GetNoArena();
}
inline void Collection::_internal_set_schema(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  schema_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Collection::set_schema(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  schema_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Crud.Collection.schema)
}
inline void Collection::set_schema(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  schema_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.Collection.schema)
}
inline void Collection::set_schema(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  schema_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.Collection.schema)
}
inline std::string* Collection::_internal_mutable_schema() {
  _has_bits_[0] |= 0x00000002u;
  return schema_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Collection::release_schema() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Collection.schema)
  if (!_internal_has_schema()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return schema_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Collection::set_allocated_schema(std::string* schema) {
  if (schema != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  schema_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), schema);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Collection.schema)
}

// -------------------------------------------------------------------

// Limit

// required uint64 row_count = 1;
inline bool Limit::_internal_has_row_count() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Limit::has_row_count() const {
  return _internal_has_row_count();
}
inline void Limit::clear_row_count() {
  row_count_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Limit::_internal_row_count() const {
  return row_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Limit::row_count() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Limit.row_count)
  return _internal_row_count();
}
inline void Limit::_internal_set_row_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  row_count_ = value;
}
inline void Limit::set_row_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_row_count(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Limit.row_count)
}

// optional uint64 offset = 2;
inline bool Limit::_internal_has_offset() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Limit::has_offset() const {
  return _internal_has_offset();
}
inline void Limit::clear_offset() {
  offset_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Limit::_internal_offset() const {
  return offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Limit::offset() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Limit.offset)
  return _internal_offset();
}
inline void Limit::_internal_set_offset(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  offset_ = value;
}
inline void Limit::set_offset(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Limit.offset)
}

// -------------------------------------------------------------------

// LimitExpr

// required .Mysqlx.Expr.Expr row_count = 1;
inline bool LimitExpr::_internal_has_row_count() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || row_count_ != nullptr);
  return value;
}
inline bool LimitExpr::has_row_count() const {
  return _internal_has_row_count();
}
inline const ::Mysqlx::Expr::Expr& LimitExpr::_internal_row_count() const {
  const ::Mysqlx::Expr::Expr* p = row_count_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Expr::Expr*>(
      &::Mysqlx::Expr::_Expr_default_instance_);
}
inline const ::Mysqlx::Expr::Expr& LimitExpr::row_count() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.LimitExpr.row_count)
  return _internal_row_count();
}
inline ::Mysqlx::Expr::Expr* LimitExpr::release_row_count() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.LimitExpr.row_count)
  _has_bits_[0] &= ~0x00000001u;
  ::Mysqlx::Expr::Expr* temp = row_count_;
  row_count_ = nullptr;
  return temp;
}
inline ::Mysqlx::Expr::Expr* LimitExpr::_internal_mutable_row_count() {
  _has_bits_[0] |= 0x00000001u;
  if (row_count_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::Expr>(GetArenaNoVirtual());
    row_count_ = p;
  }
  return row_count_;
}
inline ::Mysqlx::Expr::Expr* LimitExpr::mutable_row_count() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.LimitExpr.row_count)
  return _internal_mutable_row_count();
}
inline void LimitExpr::set_allocated_row_count(::Mysqlx::Expr::Expr* row_count) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(row_count_);
  }
  if (row_count) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      row_count = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, row_count, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  row_count_ = row_count;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.LimitExpr.row_count)
}

// optional .Mysqlx.Expr.Expr offset = 2;
inline bool LimitExpr::_internal_has_offset() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || offset_ != nullptr);
  return value;
}
inline bool LimitExpr::has_offset() const {
  return _internal_has_offset();
}
inline const ::Mysqlx::Expr::Expr& LimitExpr::_internal_offset() const {
  const ::Mysqlx::Expr::Expr* p = offset_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Expr::Expr*>(
      &::Mysqlx::Expr::_Expr_default_instance_);
}
inline const ::Mysqlx::Expr::Expr& LimitExpr::offset() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.LimitExpr.offset)
  return _internal_offset();
}
inline ::Mysqlx::Expr::Expr* LimitExpr::release_offset() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.LimitExpr.offset)
  _has_bits_[0] &= ~0x00000002u;
  ::Mysqlx::Expr::Expr* temp = offset_;
  offset_ = nullptr;
  return temp;
}
inline ::Mysqlx::Expr::Expr* LimitExpr::_internal_mutable_offset() {
  _has_bits_[0] |= 0x00000002u;
  if (offset_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::Expr>(GetArenaNoVirtual());
    offset_ = p;
  }
  return offset_;
}
inline ::Mysqlx::Expr::Expr* LimitExpr::mutable_offset() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.LimitExpr.offset)
  return _internal_mutable_offset();
}
inline void LimitExpr::set_allocated_offset(::Mysqlx::Expr::Expr* offset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(offset_);
  }
  if (offset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      offset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, offset, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  offset_ = offset;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.LimitExpr.offset)
}

// -------------------------------------------------------------------

// Order

// required .Mysqlx.Expr.Expr expr = 1;
inline bool Order::_internal_has_expr() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || expr_ != nullptr);
  return value;
}
inline bool Order::has_expr() const {
  return _internal_has_expr();
}
inline const ::Mysqlx::Expr::Expr& Order::_internal_expr() const {
  const ::Mysqlx::Expr::Expr* p = expr_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Expr::Expr*>(
      &::Mysqlx::Expr::_Expr_default_instance_);
}
inline const ::Mysqlx::Expr::Expr& Order::expr() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Order.expr)
  return _internal_expr();
}
inline ::Mysqlx::Expr::Expr* Order::release_expr() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Order.expr)
  _has_bits_[0] &= ~0x00000001u;
  ::Mysqlx::Expr::Expr* temp = expr_;
  expr_ = nullptr;
  return temp;
}
inline ::Mysqlx::Expr::Expr* Order::_internal_mutable_expr() {
  _has_bits_[0] |= 0x00000001u;
  if (expr_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::Expr>(GetArenaNoVirtual());
    expr_ = p;
  }
  return expr_;
}
inline ::Mysqlx::Expr::Expr* Order::mutable_expr() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Order.expr)
  return _internal_mutable_expr();
}
inline void Order::set_allocated_expr(::Mysqlx::Expr::Expr* expr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(expr_);
  }
  if (expr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      expr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  expr_ = expr;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Order.expr)
}

// optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
inline bool Order::_internal_has_direction() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Order::has_direction() const {
  return _internal_has_direction();
}
inline void Order::clear_direction() {
  direction_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::Mysqlx::Crud::Order_Direction Order::_internal_direction() const {
  return static_cast< ::Mysqlx::Crud::Order_Direction >(direction_);
}
inline ::Mysqlx::Crud::Order_Direction Order::direction() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Order.direction)
  return _internal_direction();
}
inline void Order::_internal_set_direction(::Mysqlx::Crud::Order_Direction value) {
  assert(::Mysqlx::Crud::Order_Direction_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  direction_ = value;
}
inline void Order::set_direction(::Mysqlx::Crud::Order_Direction value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Order.direction)
}

// -------------------------------------------------------------------

// UpdateOperation

// required .Mysqlx.Expr.ColumnIdentifier source = 1;
inline bool UpdateOperation::_internal_has_source() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || source_ != nullptr);
  return value;
}
inline bool UpdateOperation::has_source() const {
  return _internal_has_source();
}
inline const ::Mysqlx::Expr::ColumnIdentifier& UpdateOperation::_internal_source() const {
  const ::Mysqlx::Expr::ColumnIdentifier* p = source_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Expr::ColumnIdentifier*>(
      &::Mysqlx::Expr::_ColumnIdentifier_default_instance_);
}
inline const ::Mysqlx::Expr::ColumnIdentifier& UpdateOperation::source() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.UpdateOperation.source)
  return _internal_source();
}
inline ::Mysqlx::Expr::ColumnIdentifier* UpdateOperation::release_source() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.UpdateOperation.source)
  _has_bits_[0] &= ~0x00000001u;
  ::Mysqlx::Expr::ColumnIdentifier* temp = source_;
  source_ = nullptr;
  return temp;
}
inline ::Mysqlx::Expr::ColumnIdentifier* UpdateOperation::_internal_mutable_source() {
  _has_bits_[0] |= 0x00000001u;
  if (source_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::ColumnIdentifier>(GetArenaNoVirtual());
    source_ = p;
  }
  return source_;
}
inline ::Mysqlx::Expr::ColumnIdentifier* UpdateOperation::mutable_source() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.UpdateOperation.source)
  return _internal_mutable_source();
}
inline void UpdateOperation::set_allocated_source(::Mysqlx::Expr::ColumnIdentifier* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_);
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.UpdateOperation.source)
}

// required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
inline bool UpdateOperation::_internal_has_operation() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UpdateOperation::has_operation() const {
  return _internal_has_operation();
}
inline void UpdateOperation::clear_operation() {
  operation_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::Mysqlx::Crud::UpdateOperation_UpdateType UpdateOperation::_internal_operation() const {
  return static_cast< ::Mysqlx::Crud::UpdateOperation_UpdateType >(operation_);
}
inline ::Mysqlx::Crud::UpdateOperation_UpdateType UpdateOperation::operation() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.UpdateOperation.operation)
  return _internal_operation();
}
inline void UpdateOperation::_internal_set_operation(::Mysqlx::Crud::UpdateOperation_UpdateType value) {
  assert(::Mysqlx::Crud::UpdateOperation_UpdateType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  operation_ = value;
}
inline void UpdateOperation::set_operation(::Mysqlx::Crud::UpdateOperation_UpdateType value) {
  _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.UpdateOperation.operation)
}

// optional .Mysqlx.Expr.Expr value = 3;
inline bool UpdateOperation::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || value_ != nullptr);
  return value;
}
inline bool UpdateOperation::has_value() const {
  return _internal_has_value();
}
inline const ::Mysqlx::Expr::Expr& UpdateOperation::_internal_value() const {
  const ::Mysqlx::Expr::Expr* p = value_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Expr::Expr*>(
      &::Mysqlx::Expr::_Expr_default_instance_);
}
inline const ::Mysqlx::Expr::Expr& UpdateOperation::value() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.UpdateOperation.value)
  return _internal_value();
}
inline ::Mysqlx::Expr::Expr* UpdateOperation::release_value() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.UpdateOperation.value)
  _has_bits_[0] &= ~0x00000002u;
  ::Mysqlx::Expr::Expr* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::Mysqlx::Expr::Expr* UpdateOperation::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::Expr>(GetArenaNoVirtual());
    value_ = p;
  }
  return value_;
}
inline ::Mysqlx::Expr::Expr* UpdateOperation::mutable_value() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.UpdateOperation.value)
  return _internal_mutable_value();
}
inline void UpdateOperation::set_allocated_value(::Mysqlx::Expr::Expr* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.UpdateOperation.value)
}

// -------------------------------------------------------------------

// Find

// required .Mysqlx.Crud.Collection collection = 2;
inline bool Find::_internal_has_collection() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || collection_ != nullptr);
  return value;
}
inline bool Find::has_collection() const {
  return _internal_has_collection();
}
inline void Find::clear_collection() {
  if (collection_ != nullptr) collection_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Mysqlx::Crud::Collection& Find::_internal_collection() const {
  const ::Mysqlx::Crud::Collection* p = collection_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Crud::Collection*>(
      &::Mysqlx::Crud::_Collection_default_instance_);
}
inline const ::Mysqlx::Crud::Collection& Find::collection() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.collection)
  return _internal_collection();
}
inline ::Mysqlx::Crud::Collection* Find::release_collection() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Find.collection)
  _has_bits_[0] &= ~0x00000001u;
  ::Mysqlx::Crud::Collection* temp = collection_;
  collection_ = nullptr;
  return temp;
}
inline ::Mysqlx::Crud::Collection* Find::_internal_mutable_collection() {
  _has_bits_[0] |= 0x00000001u;
  if (collection_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::Collection>(GetArenaNoVirtual());
    collection_ = p;
  }
  return collection_;
}
inline ::Mysqlx::Crud::Collection* Find::mutable_collection() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.collection)
  return _internal_mutable_collection();
}
inline void Find::set_allocated_collection(::Mysqlx::Crud::Collection* collection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete collection_;
  }
  if (collection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      collection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, collection, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  collection_ = collection;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Find.collection)
}

// optional .Mysqlx.Crud.DataModel data_model = 3;
inline bool Find::_internal_has_data_model() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Find::has_data_model() const {
  return _internal_has_data_model();
}
inline void Find::clear_data_model() {
  data_model_ = 1;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::Mysqlx::Crud::DataModel Find::_internal_data_model() const {
  return static_cast< ::Mysqlx::Crud::DataModel >(data_model_);
}
inline ::Mysqlx::Crud::DataModel Find::data_model() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.data_model)
  return _internal_data_model();
}
inline void Find::_internal_set_data_model(::Mysqlx::Crud::DataModel value) {
  assert(::Mysqlx::Crud::DataModel_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  data_model_ = value;
}
inline void Find::set_data_model(::Mysqlx::Crud::DataModel value) {
  _internal_set_data_model(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Find.data_model)
}

// repeated .Mysqlx.Crud.Projection projection = 4;
inline int Find::_internal_projection_size() const {
  return projection_.size();
}
inline int Find::projection_size() const {
  return _internal_projection_size();
}
inline void Find::clear_projection() {
  projection_.Clear();
}
inline ::Mysqlx::Crud::Projection* Find::mutable_projection(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.projection)
  return projection_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Projection >*
Find::mutable_projection() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Find.projection)
  return &projection_;
}
inline const ::Mysqlx::Crud::Projection& Find::_internal_projection(int index) const {
  return projection_.Get(index);
}
inline const ::Mysqlx::Crud::Projection& Find::projection(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.projection)
  return _internal_projection(index);
}
inline ::Mysqlx::Crud::Projection* Find::_internal_add_projection() {
  return projection_.Add();
}
inline ::Mysqlx::Crud::Projection* Find::add_projection() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Find.projection)
  return _internal_add_projection();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Projection >&
Find::projection() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Find.projection)
  return projection_;
}

// optional .Mysqlx.Expr.Expr criteria = 5;
inline bool Find::_internal_has_criteria() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || criteria_ != nullptr);
  return value;
}
inline bool Find::has_criteria() const {
  return _internal_has_criteria();
}
inline const ::Mysqlx::Expr::Expr& Find::_internal_criteria() const {
  const ::Mysqlx::Expr::Expr* p = criteria_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Expr::Expr*>(
      &::Mysqlx::Expr::_Expr_default_instance_);
}
inline const ::Mysqlx::Expr::Expr& Find::criteria() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.criteria)
  return _internal_criteria();
}
inline ::Mysqlx::Expr::Expr* Find::release_criteria() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Find.criteria)
  _has_bits_[0] &= ~0x00000002u;
  ::Mysqlx::Expr::Expr* temp = criteria_;
  criteria_ = nullptr;
  return temp;
}
inline ::Mysqlx::Expr::Expr* Find::_internal_mutable_criteria() {
  _has_bits_[0] |= 0x00000002u;
  if (criteria_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::Expr>(GetArenaNoVirtual());
    criteria_ = p;
  }
  return criteria_;
}
inline ::Mysqlx::Expr::Expr* Find::mutable_criteria() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.criteria)
  return _internal_mutable_criteria();
}
inline void Find::set_allocated_criteria(::Mysqlx::Expr::Expr* criteria) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(criteria_);
  }
  if (criteria) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      criteria = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, criteria, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  criteria_ = criteria;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Find.criteria)
}

// repeated .Mysqlx.Datatypes.Scalar args = 11;
inline int Find::_internal_args_size() const {
  return args_.size();
}
inline int Find::args_size() const {
  return _internal_args_size();
}
inline ::Mysqlx::Datatypes::Scalar* Find::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.args)
  return args_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
Find::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Find.args)
  return &args_;
}
inline const ::Mysqlx::Datatypes::Scalar& Find::_internal_args(int index) const {
  return args_.Get(index);
}
inline const ::Mysqlx::Datatypes::Scalar& Find::args(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.args)
  return _internal_args(index);
}
inline ::Mysqlx::Datatypes::Scalar* Find::_internal_add_args() {
  return args_.Add();
}
inline ::Mysqlx::Datatypes::Scalar* Find::add_args() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Find.args)
  return _internal_add_args();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
Find::args() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Find.args)
  return args_;
}

// repeated .Mysqlx.Crud.Order order = 7;
inline int Find::_internal_order_size() const {
  return order_.size();
}
inline int Find::order_size() const {
  return _internal_order_size();
}
inline void Find::clear_order() {
  order_.Clear();
}
inline ::Mysqlx::Crud::Order* Find::mutable_order(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.order)
  return order_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Order >*
Find::mutable_order() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Find.order)
  return &order_;
}
inline const ::Mysqlx::Crud::Order& Find::_internal_order(int index) const {
  return order_.Get(index);
}
inline const ::Mysqlx::Crud::Order& Find::order(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.order)
  return _internal_order(index);
}
inline ::Mysqlx::Crud::Order* Find::_internal_add_order() {
  return order_.Add();
}
inline ::Mysqlx::Crud::Order* Find::add_order() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Find.order)
  return _internal_add_order();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Order >&
Find::order() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Find.order)
  return order_;
}

// repeated .Mysqlx.Expr.Expr grouping = 8;
inline int Find::_internal_grouping_size() const {
  return grouping_.size();
}
inline int Find::grouping_size() const {
  return _internal_grouping_size();
}
inline ::Mysqlx::Expr::Expr* Find::mutable_grouping(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.grouping)
  return grouping_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
Find::mutable_grouping() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Find.grouping)
  return &grouping_;
}
inline const ::Mysqlx::Expr::Expr& Find::_internal_grouping(int index) const {
  return grouping_.Get(index);
}
inline const ::Mysqlx::Expr::Expr& Find::grouping(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.grouping)
  return _internal_grouping(index);
}
inline ::Mysqlx::Expr::Expr* Find::_internal_add_grouping() {
  return grouping_.Add();
}
inline ::Mysqlx::Expr::Expr* Find::add_grouping() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Find.grouping)
  return _internal_add_grouping();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
Find::grouping() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Find.grouping)
  return grouping_;
}

// optional .Mysqlx.Expr.Expr grouping_criteria = 9;
inline bool Find::_internal_has_grouping_criteria() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || grouping_criteria_ != nullptr);
  return value;
}
inline bool Find::has_grouping_criteria() const {
  return _internal_has_grouping_criteria();
}
inline const ::Mysqlx::Expr::Expr& Find::_internal_grouping_criteria() const {
  const ::Mysqlx::Expr::Expr* p = grouping_criteria_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Expr::Expr*>(
      &::Mysqlx::Expr::_Expr_default_instance_);
}
inline const ::Mysqlx::Expr::Expr& Find::grouping_criteria() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.grouping_criteria)
  return _internal_grouping_criteria();
}
inline ::Mysqlx::Expr::Expr* Find::release_grouping_criteria() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Find.grouping_criteria)
  _has_bits_[0] &= ~0x00000008u;
  ::Mysqlx::Expr::Expr* temp = grouping_criteria_;
  grouping_criteria_ = nullptr;
  return temp;
}
inline ::Mysqlx::Expr::Expr* Find::_internal_mutable_grouping_criteria() {
  _has_bits_[0] |= 0x00000008u;
  if (grouping_criteria_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::Expr>(GetArenaNoVirtual());
    grouping_criteria_ = p;
  }
  return grouping_criteria_;
}
inline ::Mysqlx::Expr::Expr* Find::mutable_grouping_criteria() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.grouping_criteria)
  return _internal_mutable_grouping_criteria();
}
inline void Find::set_allocated_grouping_criteria(::Mysqlx::Expr::Expr* grouping_criteria) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(grouping_criteria_);
  }
  if (grouping_criteria) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      grouping_criteria = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, grouping_criteria, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  grouping_criteria_ = grouping_criteria;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Find.grouping_criteria)
}

// optional .Mysqlx.Crud.Find.RowLock locking = 12;
inline bool Find::_internal_has_locking() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Find::has_locking() const {
  return _internal_has_locking();
}
inline void Find::clear_locking() {
  locking_ = 1;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::Mysqlx::Crud::Find_RowLock Find::_internal_locking() const {
  return static_cast< ::Mysqlx::Crud::Find_RowLock >(locking_);
}
inline ::Mysqlx::Crud::Find_RowLock Find::locking() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.locking)
  return _internal_locking();
}
inline void Find::_internal_set_locking(::Mysqlx::Crud::Find_RowLock value) {
  assert(::Mysqlx::Crud::Find_RowLock_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  locking_ = value;
}
inline void Find::set_locking(::Mysqlx::Crud::Find_RowLock value) {
  _internal_set_locking(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Find.locking)
}

// optional .Mysqlx.Crud.Find.RowLockOptions locking_options = 13;
inline bool Find::_internal_has_locking_options() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Find::has_locking_options() const {
  return _internal_has_locking_options();
}
inline void Find::clear_locking_options() {
  locking_options_ = 1;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::Mysqlx::Crud::Find_RowLockOptions Find::_internal_locking_options() const {
  return static_cast< ::Mysqlx::Crud::Find_RowLockOptions >(locking_options_);
}
inline ::Mysqlx::Crud::Find_RowLockOptions Find::locking_options() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.locking_options)
  return _internal_locking_options();
}
inline void Find::_internal_set_locking_options(::Mysqlx::Crud::Find_RowLockOptions value) {
  assert(::Mysqlx::Crud::Find_RowLockOptions_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  locking_options_ = value;
}
inline void Find::set_locking_options(::Mysqlx::Crud::Find_RowLockOptions value) {
  _internal_set_locking_options(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Find.locking_options)
}

// optional .Mysqlx.Crud.Limit limit = 6;
inline bool Find::_internal_has_limit() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || limit_ != nullptr);
  return value;
}
inline bool Find::has_limit() const {
  return _internal_has_limit();
}
inline void Find::clear_limit() {
  if (limit_ != nullptr) limit_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::Mysqlx::Crud::Limit& Find::_internal_limit() const {
  const ::Mysqlx::Crud::Limit* p = limit_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Crud::Limit*>(
      &::Mysqlx::Crud::_Limit_default_instance_);
}
inline const ::Mysqlx::Crud::Limit& Find::limit() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.limit)
  return _internal_limit();
}
inline ::Mysqlx::Crud::Limit* Find::release_limit() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Find.limit)
  _has_bits_[0] &= ~0x00000004u;
  ::Mysqlx::Crud::Limit* temp = limit_;
  limit_ = nullptr;
  return temp;
}
inline ::Mysqlx::Crud::Limit* Find::_internal_mutable_limit() {
  _has_bits_[0] |= 0x00000004u;
  if (limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::Limit>(GetArenaNoVirtual());
    limit_ = p;
  }
  return limit_;
}
inline ::Mysqlx::Crud::Limit* Find::mutable_limit() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.limit)
  return _internal_mutable_limit();
}
inline void Find::set_allocated_limit(::Mysqlx::Crud::Limit* limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete limit_;
  }
  if (limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, limit, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  limit_ = limit;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Find.limit)
}

// optional .Mysqlx.Crud.LimitExpr limit_expr = 14;
inline bool Find::_internal_has_limit_expr() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || limit_expr_ != nullptr);
  return value;
}
inline bool Find::has_limit_expr() const {
  return _internal_has_limit_expr();
}
inline void Find::clear_limit_expr() {
  if (limit_expr_ != nullptr) limit_expr_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::Mysqlx::Crud::LimitExpr& Find::_internal_limit_expr() const {
  const ::Mysqlx::Crud::LimitExpr* p = limit_expr_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Crud::LimitExpr*>(
      &::Mysqlx::Crud::_LimitExpr_default_instance_);
}
inline const ::Mysqlx::Crud::LimitExpr& Find::limit_expr() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Find.limit_expr)
  return _internal_limit_expr();
}
inline ::Mysqlx::Crud::LimitExpr* Find::release_limit_expr() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Find.limit_expr)
  _has_bits_[0] &= ~0x00000010u;
  ::Mysqlx::Crud::LimitExpr* temp = limit_expr_;
  limit_expr_ = nullptr;
  return temp;
}
inline ::Mysqlx::Crud::LimitExpr* Find::_internal_mutable_limit_expr() {
  _has_bits_[0] |= 0x00000010u;
  if (limit_expr_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::LimitExpr>(GetArenaNoVirtual());
    limit_expr_ = p;
  }
  return limit_expr_;
}
inline ::Mysqlx::Crud::LimitExpr* Find::mutable_limit_expr() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Find.limit_expr)
  return _internal_mutable_limit_expr();
}
inline void Find::set_allocated_limit_expr(::Mysqlx::Crud::LimitExpr* limit_expr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete limit_expr_;
  }
  if (limit_expr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      limit_expr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, limit_expr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  limit_expr_ = limit_expr;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Find.limit_expr)
}

// -------------------------------------------------------------------

// Insert_TypedRow

// repeated .Mysqlx.Expr.Expr field = 1;
inline int Insert_TypedRow::_internal_field_size() const {
  return field_.size();
}
inline int Insert_TypedRow::field_size() const {
  return _internal_field_size();
}
inline ::Mysqlx::Expr::Expr* Insert_TypedRow::mutable_field(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Insert.TypedRow.field)
  return field_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Expr >*
Insert_TypedRow::mutable_field() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Insert.TypedRow.field)
  return &field_;
}
inline const ::Mysqlx::Expr::Expr& Insert_TypedRow::_internal_field(int index) const {
  return field_.Get(index);
}
inline const ::Mysqlx::Expr::Expr& Insert_TypedRow::field(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.TypedRow.field)
  return _internal_field(index);
}
inline ::Mysqlx::Expr::Expr* Insert_TypedRow::_internal_add_field() {
  return field_.Add();
}
inline ::Mysqlx::Expr::Expr* Insert_TypedRow::add_field() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Insert.TypedRow.field)
  return _internal_add_field();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Expr::Expr >&
Insert_TypedRow::field() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Insert.TypedRow.field)
  return field_;
}

// -------------------------------------------------------------------

// Insert

// required .Mysqlx.Crud.Collection collection = 1;
inline bool Insert::_internal_has_collection() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || collection_ != nullptr);
  return value;
}
inline bool Insert::has_collection() const {
  return _internal_has_collection();
}
inline void Insert::clear_collection() {
  if (collection_ != nullptr) collection_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Mysqlx::Crud::Collection& Insert::_internal_collection() const {
  const ::Mysqlx::Crud::Collection* p = collection_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Crud::Collection*>(
      &::Mysqlx::Crud::_Collection_default_instance_);
}
inline const ::Mysqlx::Crud::Collection& Insert::collection() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.collection)
  return _internal_collection();
}
inline ::Mysqlx::Crud::Collection* Insert::release_collection() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Insert.collection)
  _has_bits_[0] &= ~0x00000001u;
  ::Mysqlx::Crud::Collection* temp = collection_;
  collection_ = nullptr;
  return temp;
}
inline ::Mysqlx::Crud::Collection* Insert::_internal_mutable_collection() {
  _has_bits_[0] |= 0x00000001u;
  if (collection_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::Collection>(GetArenaNoVirtual());
    collection_ = p;
  }
  return collection_;
}
inline ::Mysqlx::Crud::Collection* Insert::mutable_collection() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Insert.collection)
  return _internal_mutable_collection();
}
inline void Insert::set_allocated_collection(::Mysqlx::Crud::Collection* collection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete collection_;
  }
  if (collection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      collection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, collection, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  collection_ = collection;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Insert.collection)
}

// optional .Mysqlx.Crud.DataModel data_model = 2;
inline bool Insert::_internal_has_data_model() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Insert::has_data_model() const {
  return _internal_has_data_model();
}
inline void Insert::clear_data_model() {
  data_model_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::Mysqlx::Crud::DataModel Insert::_internal_data_model() const {
  return static_cast< ::Mysqlx::Crud::DataModel >(data_model_);
}
inline ::Mysqlx::Crud::DataModel Insert::data_model() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.data_model)
  return _internal_data_model();
}
inline void Insert::_internal_set_data_model(::Mysqlx::Crud::DataModel value) {
  assert(::Mysqlx::Crud::DataModel_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  data_model_ = value;
}
inline void Insert::set_data_model(::Mysqlx::Crud::DataModel value) {
  _internal_set_data_model(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Insert.data_model)
}

// repeated .Mysqlx.Crud.Column projection = 3;
inline int Insert::_internal_projection_size() const {
  return projection_.size();
}
inline int Insert::projection_size() const {
  return _internal_projection_size();
}
inline void Insert::clear_projection() {
  projection_.Clear();
}
inline ::Mysqlx::Crud::Column* Insert::mutable_projection(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Insert.projection)
  return projection_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Column >*
Insert::mutable_projection() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Insert.projection)
  return &projection_;
}
inline const ::Mysqlx::Crud::Column& Insert::_internal_projection(int index) const {
  return projection_.Get(index);
}
inline const ::Mysqlx::Crud::Column& Insert::projection(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.projection)
  return _internal_projection(index);
}
inline ::Mysqlx::Crud::Column* Insert::_internal_add_projection() {
  return projection_.Add();
}
inline ::Mysqlx::Crud::Column* Insert::add_projection() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Insert.projection)
  return _internal_add_projection();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Column >&
Insert::projection() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Insert.projection)
  return projection_;
}

// repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
inline int Insert::_internal_row_size() const {
  return row_.size();
}
inline int Insert::row_size() const {
  return _internal_row_size();
}
inline void Insert::clear_row() {
  row_.Clear();
}
inline ::Mysqlx::Crud::Insert_TypedRow* Insert::mutable_row(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Insert.row)
  return row_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Insert_TypedRow >*
Insert::mutable_row() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Insert.row)
  return &row_;
}
inline const ::Mysqlx::Crud::Insert_TypedRow& Insert::_internal_row(int index) const {
  return row_.Get(index);
}
inline const ::Mysqlx::Crud::Insert_TypedRow& Insert::row(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.row)
  return _internal_row(index);
}
inline ::Mysqlx::Crud::Insert_TypedRow* Insert::_internal_add_row() {
  return row_.Add();
}
inline ::Mysqlx::Crud::Insert_TypedRow* Insert::add_row() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Insert.row)
  return _internal_add_row();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Insert_TypedRow >&
Insert::row() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Insert.row)
  return row_;
}

// repeated .Mysqlx.Datatypes.Scalar args = 5;
inline int Insert::_internal_args_size() const {
  return args_.size();
}
inline int Insert::args_size() const {
  return _internal_args_size();
}
inline ::Mysqlx::Datatypes::Scalar* Insert::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Insert.args)
  return args_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
Insert::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Insert.args)
  return &args_;
}
inline const ::Mysqlx::Datatypes::Scalar& Insert::_internal_args(int index) const {
  return args_.Get(index);
}
inline const ::Mysqlx::Datatypes::Scalar& Insert::args(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.args)
  return _internal_args(index);
}
inline ::Mysqlx::Datatypes::Scalar* Insert::_internal_add_args() {
  return args_.Add();
}
inline ::Mysqlx::Datatypes::Scalar* Insert::add_args() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Insert.args)
  return _internal_add_args();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
Insert::args() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Insert.args)
  return args_;
}

// optional bool upsert = 6 [default = false];
inline bool Insert::_internal_has_upsert() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Insert::has_upsert() const {
  return _internal_has_upsert();
}
inline void Insert::clear_upsert() {
  upsert_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool Insert::_internal_upsert() const {
  return upsert_;
}
inline bool Insert::upsert() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Insert.upsert)
  return _internal_upsert();
}
inline void Insert::_internal_set_upsert(bool value) {
  _has_bits_[0] |= 0x00000002u;
  upsert_ = value;
}
inline void Insert::set_upsert(bool value) {
  _internal_set_upsert(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Insert.upsert)
}

// -------------------------------------------------------------------

// Update

// required .Mysqlx.Crud.Collection collection = 2;
inline bool Update::_internal_has_collection() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || collection_ != nullptr);
  return value;
}
inline bool Update::has_collection() const {
  return _internal_has_collection();
}
inline void Update::clear_collection() {
  if (collection_ != nullptr) collection_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Mysqlx::Crud::Collection& Update::_internal_collection() const {
  const ::Mysqlx::Crud::Collection* p = collection_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Crud::Collection*>(
      &::Mysqlx::Crud::_Collection_default_instance_);
}
inline const ::Mysqlx::Crud::Collection& Update::collection() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.collection)
  return _internal_collection();
}
inline ::Mysqlx::Crud::Collection* Update::release_collection() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Update.collection)
  _has_bits_[0] &= ~0x00000001u;
  ::Mysqlx::Crud::Collection* temp = collection_;
  collection_ = nullptr;
  return temp;
}
inline ::Mysqlx::Crud::Collection* Update::_internal_mutable_collection() {
  _has_bits_[0] |= 0x00000001u;
  if (collection_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::Collection>(GetArenaNoVirtual());
    collection_ = p;
  }
  return collection_;
}
inline ::Mysqlx::Crud::Collection* Update::mutable_collection() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.collection)
  return _internal_mutable_collection();
}
inline void Update::set_allocated_collection(::Mysqlx::Crud::Collection* collection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete collection_;
  }
  if (collection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      collection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, collection, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  collection_ = collection;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Update.collection)
}

// optional .Mysqlx.Crud.DataModel data_model = 3;
inline bool Update::_internal_has_data_model() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Update::has_data_model() const {
  return _internal_has_data_model();
}
inline void Update::clear_data_model() {
  data_model_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::Mysqlx::Crud::DataModel Update::_internal_data_model() const {
  return static_cast< ::Mysqlx::Crud::DataModel >(data_model_);
}
inline ::Mysqlx::Crud::DataModel Update::data_model() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.data_model)
  return _internal_data_model();
}
inline void Update::_internal_set_data_model(::Mysqlx::Crud::DataModel value) {
  assert(::Mysqlx::Crud::DataModel_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  data_model_ = value;
}
inline void Update::set_data_model(::Mysqlx::Crud::DataModel value) {
  _internal_set_data_model(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Update.data_model)
}

// optional .Mysqlx.Expr.Expr criteria = 4;
inline bool Update::_internal_has_criteria() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || criteria_ != nullptr);
  return value;
}
inline bool Update::has_criteria() const {
  return _internal_has_criteria();
}
inline const ::Mysqlx::Expr::Expr& Update::_internal_criteria() const {
  const ::Mysqlx::Expr::Expr* p = criteria_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Expr::Expr*>(
      &::Mysqlx::Expr::_Expr_default_instance_);
}
inline const ::Mysqlx::Expr::Expr& Update::criteria() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.criteria)
  return _internal_criteria();
}
inline ::Mysqlx::Expr::Expr* Update::release_criteria() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Update.criteria)
  _has_bits_[0] &= ~0x00000002u;
  ::Mysqlx::Expr::Expr* temp = criteria_;
  criteria_ = nullptr;
  return temp;
}
inline ::Mysqlx::Expr::Expr* Update::_internal_mutable_criteria() {
  _has_bits_[0] |= 0x00000002u;
  if (criteria_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::Expr>(GetArenaNoVirtual());
    criteria_ = p;
  }
  return criteria_;
}
inline ::Mysqlx::Expr::Expr* Update::mutable_criteria() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.criteria)
  return _internal_mutable_criteria();
}
inline void Update::set_allocated_criteria(::Mysqlx::Expr::Expr* criteria) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(criteria_);
  }
  if (criteria) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      criteria = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, criteria, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  criteria_ = criteria;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Update.criteria)
}

// repeated .Mysqlx.Datatypes.Scalar args = 8;
inline int Update::_internal_args_size() const {
  return args_.size();
}
inline int Update::args_size() const {
  return _internal_args_size();
}
inline ::Mysqlx::Datatypes::Scalar* Update::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.args)
  return args_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
Update::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Update.args)
  return &args_;
}
inline const ::Mysqlx::Datatypes::Scalar& Update::_internal_args(int index) const {
  return args_.Get(index);
}
inline const ::Mysqlx::Datatypes::Scalar& Update::args(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.args)
  return _internal_args(index);
}
inline ::Mysqlx::Datatypes::Scalar* Update::_internal_add_args() {
  return args_.Add();
}
inline ::Mysqlx::Datatypes::Scalar* Update::add_args() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Update.args)
  return _internal_add_args();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
Update::args() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Update.args)
  return args_;
}

// repeated .Mysqlx.Crud.Order order = 6;
inline int Update::_internal_order_size() const {
  return order_.size();
}
inline int Update::order_size() const {
  return _internal_order_size();
}
inline void Update::clear_order() {
  order_.Clear();
}
inline ::Mysqlx::Crud::Order* Update::mutable_order(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.order)
  return order_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Order >*
Update::mutable_order() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Update.order)
  return &order_;
}
inline const ::Mysqlx::Crud::Order& Update::_internal_order(int index) const {
  return order_.Get(index);
}
inline const ::Mysqlx::Crud::Order& Update::order(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.order)
  return _internal_order(index);
}
inline ::Mysqlx::Crud::Order* Update::_internal_add_order() {
  return order_.Add();
}
inline ::Mysqlx::Crud::Order* Update::add_order() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Update.order)
  return _internal_add_order();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Order >&
Update::order() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Update.order)
  return order_;
}

// repeated .Mysqlx.Crud.UpdateOperation operation = 7;
inline int Update::_internal_operation_size() const {
  return operation_.size();
}
inline int Update::operation_size() const {
  return _internal_operation_size();
}
inline void Update::clear_operation() {
  operation_.Clear();
}
inline ::Mysqlx::Crud::UpdateOperation* Update::mutable_operation(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.operation)
  return operation_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::UpdateOperation >*
Update::mutable_operation() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Update.operation)
  return &operation_;
}
inline const ::Mysqlx::Crud::UpdateOperation& Update::_internal_operation(int index) const {
  return operation_.Get(index);
}
inline const ::Mysqlx::Crud::UpdateOperation& Update::operation(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.operation)
  return _internal_operation(index);
}
inline ::Mysqlx::Crud::UpdateOperation* Update::_internal_add_operation() {
  return operation_.Add();
}
inline ::Mysqlx::Crud::UpdateOperation* Update::add_operation() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Update.operation)
  return _internal_add_operation();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::UpdateOperation >&
Update::operation() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Update.operation)
  return operation_;
}

// optional .Mysqlx.Crud.Limit limit = 5;
inline bool Update::_internal_has_limit() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || limit_ != nullptr);
  return value;
}
inline bool Update::has_limit() const {
  return _internal_has_limit();
}
inline void Update::clear_limit() {
  if (limit_ != nullptr) limit_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::Mysqlx::Crud::Limit& Update::_internal_limit() const {
  const ::Mysqlx::Crud::Limit* p = limit_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Crud::Limit*>(
      &::Mysqlx::Crud::_Limit_default_instance_);
}
inline const ::Mysqlx::Crud::Limit& Update::limit() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.limit)
  return _internal_limit();
}
inline ::Mysqlx::Crud::Limit* Update::release_limit() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Update.limit)
  _has_bits_[0] &= ~0x00000004u;
  ::Mysqlx::Crud::Limit* temp = limit_;
  limit_ = nullptr;
  return temp;
}
inline ::Mysqlx::Crud::Limit* Update::_internal_mutable_limit() {
  _has_bits_[0] |= 0x00000004u;
  if (limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::Limit>(GetArenaNoVirtual());
    limit_ = p;
  }
  return limit_;
}
inline ::Mysqlx::Crud::Limit* Update::mutable_limit() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.limit)
  return _internal_mutable_limit();
}
inline void Update::set_allocated_limit(::Mysqlx::Crud::Limit* limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete limit_;
  }
  if (limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, limit, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  limit_ = limit;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Update.limit)
}

// optional .Mysqlx.Crud.LimitExpr limit_expr = 9;
inline bool Update::_internal_has_limit_expr() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || limit_expr_ != nullptr);
  return value;
}
inline bool Update::has_limit_expr() const {
  return _internal_has_limit_expr();
}
inline void Update::clear_limit_expr() {
  if (limit_expr_ != nullptr) limit_expr_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::Mysqlx::Crud::LimitExpr& Update::_internal_limit_expr() const {
  const ::Mysqlx::Crud::LimitExpr* p = limit_expr_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Crud::LimitExpr*>(
      &::Mysqlx::Crud::_LimitExpr_default_instance_);
}
inline const ::Mysqlx::Crud::LimitExpr& Update::limit_expr() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Update.limit_expr)
  return _internal_limit_expr();
}
inline ::Mysqlx::Crud::LimitExpr* Update::release_limit_expr() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Update.limit_expr)
  _has_bits_[0] &= ~0x00000008u;
  ::Mysqlx::Crud::LimitExpr* temp = limit_expr_;
  limit_expr_ = nullptr;
  return temp;
}
inline ::Mysqlx::Crud::LimitExpr* Update::_internal_mutable_limit_expr() {
  _has_bits_[0] |= 0x00000008u;
  if (limit_expr_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::LimitExpr>(GetArenaNoVirtual());
    limit_expr_ = p;
  }
  return limit_expr_;
}
inline ::Mysqlx::Crud::LimitExpr* Update::mutable_limit_expr() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Update.limit_expr)
  return _internal_mutable_limit_expr();
}
inline void Update::set_allocated_limit_expr(::Mysqlx::Crud::LimitExpr* limit_expr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete limit_expr_;
  }
  if (limit_expr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      limit_expr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, limit_expr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  limit_expr_ = limit_expr;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Update.limit_expr)
}

// -------------------------------------------------------------------

// Delete

// required .Mysqlx.Crud.Collection collection = 1;
inline bool Delete::_internal_has_collection() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || collection_ != nullptr);
  return value;
}
inline bool Delete::has_collection() const {
  return _internal_has_collection();
}
inline void Delete::clear_collection() {
  if (collection_ != nullptr) collection_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Mysqlx::Crud::Collection& Delete::_internal_collection() const {
  const ::Mysqlx::Crud::Collection* p = collection_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Crud::Collection*>(
      &::Mysqlx::Crud::_Collection_default_instance_);
}
inline const ::Mysqlx::Crud::Collection& Delete::collection() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.collection)
  return _internal_collection();
}
inline ::Mysqlx::Crud::Collection* Delete::release_collection() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Delete.collection)
  _has_bits_[0] &= ~0x00000001u;
  ::Mysqlx::Crud::Collection* temp = collection_;
  collection_ = nullptr;
  return temp;
}
inline ::Mysqlx::Crud::Collection* Delete::_internal_mutable_collection() {
  _has_bits_[0] |= 0x00000001u;
  if (collection_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::Collection>(GetArenaNoVirtual());
    collection_ = p;
  }
  return collection_;
}
inline ::Mysqlx::Crud::Collection* Delete::mutable_collection() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Delete.collection)
  return _internal_mutable_collection();
}
inline void Delete::set_allocated_collection(::Mysqlx::Crud::Collection* collection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete collection_;
  }
  if (collection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      collection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, collection, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  collection_ = collection;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Delete.collection)
}

// optional .Mysqlx.Crud.DataModel data_model = 2;
inline bool Delete::_internal_has_data_model() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Delete::has_data_model() const {
  return _internal_has_data_model();
}
inline void Delete::clear_data_model() {
  data_model_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::Mysqlx::Crud::DataModel Delete::_internal_data_model() const {
  return static_cast< ::Mysqlx::Crud::DataModel >(data_model_);
}
inline ::Mysqlx::Crud::DataModel Delete::data_model() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.data_model)
  return _internal_data_model();
}
inline void Delete::_internal_set_data_model(::Mysqlx::Crud::DataModel value) {
  assert(::Mysqlx::Crud::DataModel_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  data_model_ = value;
}
inline void Delete::set_data_model(::Mysqlx::Crud::DataModel value) {
  _internal_set_data_model(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.Delete.data_model)
}

// optional .Mysqlx.Expr.Expr criteria = 3;
inline bool Delete::_internal_has_criteria() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || criteria_ != nullptr);
  return value;
}
inline bool Delete::has_criteria() const {
  return _internal_has_criteria();
}
inline const ::Mysqlx::Expr::Expr& Delete::_internal_criteria() const {
  const ::Mysqlx::Expr::Expr* p = criteria_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Expr::Expr*>(
      &::Mysqlx::Expr::_Expr_default_instance_);
}
inline const ::Mysqlx::Expr::Expr& Delete::criteria() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.criteria)
  return _internal_criteria();
}
inline ::Mysqlx::Expr::Expr* Delete::release_criteria() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Delete.criteria)
  _has_bits_[0] &= ~0x00000002u;
  ::Mysqlx::Expr::Expr* temp = criteria_;
  criteria_ = nullptr;
  return temp;
}
inline ::Mysqlx::Expr::Expr* Delete::_internal_mutable_criteria() {
  _has_bits_[0] |= 0x00000002u;
  if (criteria_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Expr::Expr>(GetArenaNoVirtual());
    criteria_ = p;
  }
  return criteria_;
}
inline ::Mysqlx::Expr::Expr* Delete::mutable_criteria() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Delete.criteria)
  return _internal_mutable_criteria();
}
inline void Delete::set_allocated_criteria(::Mysqlx::Expr::Expr* criteria) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(criteria_);
  }
  if (criteria) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      criteria = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, criteria, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  criteria_ = criteria;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Delete.criteria)
}

// repeated .Mysqlx.Datatypes.Scalar args = 6;
inline int Delete::_internal_args_size() const {
  return args_.size();
}
inline int Delete::args_size() const {
  return _internal_args_size();
}
inline ::Mysqlx::Datatypes::Scalar* Delete::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Delete.args)
  return args_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >*
Delete::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Delete.args)
  return &args_;
}
inline const ::Mysqlx::Datatypes::Scalar& Delete::_internal_args(int index) const {
  return args_.Get(index);
}
inline const ::Mysqlx::Datatypes::Scalar& Delete::args(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.args)
  return _internal_args(index);
}
inline ::Mysqlx::Datatypes::Scalar* Delete::_internal_add_args() {
  return args_.Add();
}
inline ::Mysqlx::Datatypes::Scalar* Delete::add_args() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Delete.args)
  return _internal_add_args();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Datatypes::Scalar >&
Delete::args() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Delete.args)
  return args_;
}

// repeated .Mysqlx.Crud.Order order = 5;
inline int Delete::_internal_order_size() const {
  return order_.size();
}
inline int Delete::order_size() const {
  return _internal_order_size();
}
inline void Delete::clear_order() {
  order_.Clear();
}
inline ::Mysqlx::Crud::Order* Delete::mutable_order(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Delete.order)
  return order_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Order >*
Delete::mutable_order() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.Delete.order)
  return &order_;
}
inline const ::Mysqlx::Crud::Order& Delete::_internal_order(int index) const {
  return order_.Get(index);
}
inline const ::Mysqlx::Crud::Order& Delete::order(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.order)
  return _internal_order(index);
}
inline ::Mysqlx::Crud::Order* Delete::_internal_add_order() {
  return order_.Add();
}
inline ::Mysqlx::Crud::Order* Delete::add_order() {
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.Delete.order)
  return _internal_add_order();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Mysqlx::Crud::Order >&
Delete::order() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.Delete.order)
  return order_;
}

// optional .Mysqlx.Crud.Limit limit = 4;
inline bool Delete::_internal_has_limit() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || limit_ != nullptr);
  return value;
}
inline bool Delete::has_limit() const {
  return _internal_has_limit();
}
inline void Delete::clear_limit() {
  if (limit_ != nullptr) limit_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::Mysqlx::Crud::Limit& Delete::_internal_limit() const {
  const ::Mysqlx::Crud::Limit* p = limit_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Crud::Limit*>(
      &::Mysqlx::Crud::_Limit_default_instance_);
}
inline const ::Mysqlx::Crud::Limit& Delete::limit() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.limit)
  return _internal_limit();
}
inline ::Mysqlx::Crud::Limit* Delete::release_limit() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Delete.limit)
  _has_bits_[0] &= ~0x00000004u;
  ::Mysqlx::Crud::Limit* temp = limit_;
  limit_ = nullptr;
  return temp;
}
inline ::Mysqlx::Crud::Limit* Delete::_internal_mutable_limit() {
  _has_bits_[0] |= 0x00000004u;
  if (limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::Limit>(GetArenaNoVirtual());
    limit_ = p;
  }
  return limit_;
}
inline ::Mysqlx::Crud::Limit* Delete::mutable_limit() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Delete.limit)
  return _internal_mutable_limit();
}
inline void Delete::set_allocated_limit(::Mysqlx::Crud::Limit* limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete limit_;
  }
  if (limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, limit, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  limit_ = limit;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Delete.limit)
}

// optional .Mysqlx.Crud.LimitExpr limit_expr = 7;
inline bool Delete::_internal_has_limit_expr() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || limit_expr_ != nullptr);
  return value;
}
inline bool Delete::has_limit_expr() const {
  return _internal_has_limit_expr();
}
inline void Delete::clear_limit_expr() {
  if (limit_expr_ != nullptr) limit_expr_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::Mysqlx::Crud::LimitExpr& Delete::_internal_limit_expr() const {
  const ::Mysqlx::Crud::LimitExpr* p = limit_expr_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Crud::LimitExpr*>(
      &::Mysqlx::Crud::_LimitExpr_default_instance_);
}
inline const ::Mysqlx::Crud::LimitExpr& Delete::limit_expr() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.Delete.limit_expr)
  return _internal_limit_expr();
}
inline ::Mysqlx::Crud::LimitExpr* Delete::release_limit_expr() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.Delete.limit_expr)
  _has_bits_[0] &= ~0x00000008u;
  ::Mysqlx::Crud::LimitExpr* temp = limit_expr_;
  limit_expr_ = nullptr;
  return temp;
}
inline ::Mysqlx::Crud::LimitExpr* Delete::_internal_mutable_limit_expr() {
  _has_bits_[0] |= 0x00000008u;
  if (limit_expr_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::LimitExpr>(GetArenaNoVirtual());
    limit_expr_ = p;
  }
  return limit_expr_;
}
inline ::Mysqlx::Crud::LimitExpr* Delete::mutable_limit_expr() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.Delete.limit_expr)
  return _internal_mutable_limit_expr();
}
inline void Delete::set_allocated_limit_expr(::Mysqlx::Crud::LimitExpr* limit_expr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete limit_expr_;
  }
  if (limit_expr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      limit_expr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, limit_expr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  limit_expr_ = limit_expr;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.Delete.limit_expr)
}

// -------------------------------------------------------------------

// CreateView

// required .Mysqlx.Crud.Collection collection = 1;
inline bool CreateView::_internal_has_collection() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || collection_ != nullptr);
  return value;
}
inline bool CreateView::has_collection() const {
  return _internal_has_collection();
}
inline void CreateView::clear_collection() {
  if (collection_ != nullptr) collection_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::Mysqlx::Crud::Collection& CreateView::_internal_collection() const {
  const ::Mysqlx::Crud::Collection* p = collection_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Crud::Collection*>(
      &::Mysqlx::Crud::_Collection_default_instance_);
}
inline const ::Mysqlx::Crud::Collection& CreateView::collection() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.CreateView.collection)
  return _internal_collection();
}
inline ::Mysqlx::Crud::Collection* CreateView::release_collection() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.CreateView.collection)
  _has_bits_[0] &= ~0x00000002u;
  ::Mysqlx::Crud::Collection* temp = collection_;
  collection_ = nullptr;
  return temp;
}
inline ::Mysqlx::Crud::Collection* CreateView::_internal_mutable_collection() {
  _has_bits_[0] |= 0x00000002u;
  if (collection_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::Collection>(GetArenaNoVirtual());
    collection_ = p;
  }
  return collection_;
}
inline ::Mysqlx::Crud::Collection* CreateView::mutable_collection() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.CreateView.collection)
  return _internal_mutable_collection();
}
inline void CreateView::set_allocated_collection(::Mysqlx::Crud::Collection* collection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete collection_;
  }
  if (collection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      collection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, collection, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  collection_ = collection;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.CreateView.collection)
}

// optional string definer = 2;
inline bool CreateView::_internal_has_definer() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CreateView::has_definer() const {
  return _internal_has_definer();
}
inline void CreateView::clear_definer() {
  definer_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CreateView::definer() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.CreateView.definer)
  return _internal_definer();
}
inline void CreateView::set_definer(const std::string& value) {
  _internal_set_definer(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.CreateView.definer)
}
inline std::string* CreateView::mutable_definer() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.CreateView.definer)
  return _internal_mutable_definer();
}
inline const std::string& CreateView::_internal_definer() const {
  return definer_.GetNoArena();
}
inline void CreateView::_internal_set_definer(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  definer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void CreateView::set_definer(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  definer_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Crud.CreateView.definer)
}
inline void CreateView::set_definer(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  definer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.CreateView.definer)
}
inline void CreateView::set_definer(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  definer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.CreateView.definer)
}
inline std::string* CreateView::_internal_mutable_definer() {
  _has_bits_[0] |= 0x00000001u;
  return definer_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CreateView::release_definer() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.CreateView.definer)
  if (!_internal_has_definer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return definer_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CreateView::set_allocated_definer(std::string* definer) {
  if (definer != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  definer_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), definer);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.CreateView.definer)
}

// optional .Mysqlx.Crud.ViewAlgorithm algorithm = 3 [default = UNDEFINED];
inline bool CreateView::_internal_has_algorithm() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CreateView::has_algorithm() const {
  return _internal_has_algorithm();
}
inline void CreateView::clear_algorithm() {
  algorithm_ = 1;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::Mysqlx::Crud::ViewAlgorithm CreateView::_internal_algorithm() const {
  return static_cast< ::Mysqlx::Crud::ViewAlgorithm >(algorithm_);
}
inline ::Mysqlx::Crud::ViewAlgorithm CreateView::algorithm() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.CreateView.algorithm)
  return _internal_algorithm();
}
inline void CreateView::_internal_set_algorithm(::Mysqlx::Crud::ViewAlgorithm value) {
  assert(::Mysqlx::Crud::ViewAlgorithm_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  algorithm_ = value;
}
inline void CreateView::set_algorithm(::Mysqlx::Crud::ViewAlgorithm value) {
  _internal_set_algorithm(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.CreateView.algorithm)
}

// optional .Mysqlx.Crud.ViewSqlSecurity security = 4 [default = DEFINER];
inline bool CreateView::_internal_has_security() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CreateView::has_security() const {
  return _internal_has_security();
}
inline void CreateView::clear_security() {
  security_ = 2;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::Mysqlx::Crud::ViewSqlSecurity CreateView::_internal_security() const {
  return static_cast< ::Mysqlx::Crud::ViewSqlSecurity >(security_);
}
inline ::Mysqlx::Crud::ViewSqlSecurity CreateView::security() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.CreateView.security)
  return _internal_security();
}
inline void CreateView::_internal_set_security(::Mysqlx::Crud::ViewSqlSecurity value) {
  assert(::Mysqlx::Crud::ViewSqlSecurity_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  security_ = value;
}
inline void CreateView::set_security(::Mysqlx::Crud::ViewSqlSecurity value) {
  _internal_set_security(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.CreateView.security)
}

// optional .Mysqlx.Crud.ViewCheckOption check = 5;
inline bool CreateView::_internal_has_check() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CreateView::has_check() const {
  return _internal_has_check();
}
inline void CreateView::clear_check() {
  check_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::Mysqlx::Crud::ViewCheckOption CreateView::_internal_check() const {
  return static_cast< ::Mysqlx::Crud::ViewCheckOption >(check_);
}
inline ::Mysqlx::Crud::ViewCheckOption CreateView::check() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.CreateView.check)
  return _internal_check();
}
inline void CreateView::_internal_set_check(::Mysqlx::Crud::ViewCheckOption value) {
  assert(::Mysqlx::Crud::ViewCheckOption_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  check_ = value;
}
inline void CreateView::set_check(::Mysqlx::Crud::ViewCheckOption value) {
  _internal_set_check(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.CreateView.check)
}

// repeated string column = 6;
inline int CreateView::_internal_column_size() const {
  return column_.size();
}
inline int CreateView::column_size() const {
  return _internal_column_size();
}
inline void CreateView::clear_column() {
  column_.Clear();
}
inline std::string* CreateView::add_column() {
  // @@protoc_insertion_point(field_add_mutable:Mysqlx.Crud.CreateView.column)
  return _internal_add_column();
}
inline const std::string& CreateView::_internal_column(int index) const {
  return column_.Get(index);
}
inline const std::string& CreateView::column(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.CreateView.column)
  return _internal_column(index);
}
inline std::string* CreateView::mutable_column(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.CreateView.column)
  return column_.Mutable(index);
}
inline void CreateView::set_column(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.CreateView.column)
  column_.Mutable(index)->assign(value);
}
inline void CreateView::set_column(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.CreateView.column)
  column_.Mutable(index)->assign(std::move(value));
}
inline void CreateView::set_column(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  column_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.CreateView.column)
}
inline void CreateView::set_column(int index, const char* value, size_t size) {
  column_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.CreateView.column)
}
inline std::string* CreateView::_internal_add_column() {
  return column_.Add();
}
inline void CreateView::add_column(const std::string& value) {
  column_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.CreateView.column)
}
inline void CreateView::add_column(std::string&& value) {
  column_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.CreateView.column)
}
inline void CreateView::add_column(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  column_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Mysqlx.Crud.CreateView.column)
}
inline void CreateView::add_column(const char* value, size_t size) {
  column_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Mysqlx.Crud.CreateView.column)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CreateView::column() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.CreateView.column)
  return column_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CreateView::mutable_column() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.CreateView.column)
  return &column_;
}

// required .Mysqlx.Crud.Find stmt = 7;
inline bool CreateView::_internal_has_stmt() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || stmt_ != nullptr);
  return value;
}
inline bool CreateView::has_stmt() const {
  return _internal_has_stmt();
}
inline void CreateView::clear_stmt() {
  if (stmt_ != nullptr) stmt_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::Mysqlx::Crud::Find& CreateView::_internal_stmt() const {
  const ::Mysqlx::Crud::Find* p = stmt_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Crud::Find*>(
      &::Mysqlx::Crud::_Find_default_instance_);
}
inline const ::Mysqlx::Crud::Find& CreateView::stmt() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.CreateView.stmt)
  return _internal_stmt();
}
inline ::Mysqlx::Crud::Find* CreateView::release_stmt() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.CreateView.stmt)
  _has_bits_[0] &= ~0x00000004u;
  ::Mysqlx::Crud::Find* temp = stmt_;
  stmt_ = nullptr;
  return temp;
}
inline ::Mysqlx::Crud::Find* CreateView::_internal_mutable_stmt() {
  _has_bits_[0] |= 0x00000004u;
  if (stmt_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::Find>(GetArenaNoVirtual());
    stmt_ = p;
  }
  return stmt_;
}
inline ::Mysqlx::Crud::Find* CreateView::mutable_stmt() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.CreateView.stmt)
  return _internal_mutable_stmt();
}
inline void CreateView::set_allocated_stmt(::Mysqlx::Crud::Find* stmt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete stmt_;
  }
  if (stmt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      stmt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stmt, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  stmt_ = stmt;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.CreateView.stmt)
}

// optional bool replace_existing = 8 [default = false];
inline bool CreateView::_internal_has_replace_existing() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CreateView::has_replace_existing() const {
  return _internal_has_replace_existing();
}
inline void CreateView::clear_replace_existing() {
  replace_existing_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool CreateView::_internal_replace_existing() const {
  return replace_existing_;
}
inline bool CreateView::replace_existing() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.CreateView.replace_existing)
  return _internal_replace_existing();
}
inline void CreateView::_internal_set_replace_existing(bool value) {
  _has_bits_[0] |= 0x00000008u;
  replace_existing_ = value;
}
inline void CreateView::set_replace_existing(bool value) {
  _internal_set_replace_existing(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.CreateView.replace_existing)
}

// -------------------------------------------------------------------

// ModifyView

// required .Mysqlx.Crud.Collection collection = 1;
inline bool ModifyView::_internal_has_collection() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || collection_ != nullptr);
  return value;
}
inline bool ModifyView::has_collection() const {
  return _internal_has_collection();
}
inline void ModifyView::clear_collection() {
  if (collection_ != nullptr) collection_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::Mysqlx::Crud::Collection& ModifyView::_internal_collection() const {
  const ::Mysqlx::Crud::Collection* p = collection_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Crud::Collection*>(
      &::Mysqlx::Crud::_Collection_default_instance_);
}
inline const ::Mysqlx::Crud::Collection& ModifyView::collection() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.ModifyView.collection)
  return _internal_collection();
}
inline ::Mysqlx::Crud::Collection* ModifyView::release_collection() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.ModifyView.collection)
  _has_bits_[0] &= ~0x00000002u;
  ::Mysqlx::Crud::Collection* temp = collection_;
  collection_ = nullptr;
  return temp;
}
inline ::Mysqlx::Crud::Collection* ModifyView::_internal_mutable_collection() {
  _has_bits_[0] |= 0x00000002u;
  if (collection_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::Collection>(GetArenaNoVirtual());
    collection_ = p;
  }
  return collection_;
}
inline ::Mysqlx::Crud::Collection* ModifyView::mutable_collection() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.ModifyView.collection)
  return _internal_mutable_collection();
}
inline void ModifyView::set_allocated_collection(::Mysqlx::Crud::Collection* collection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete collection_;
  }
  if (collection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      collection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, collection, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  collection_ = collection;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.ModifyView.collection)
}

// optional string definer = 2;
inline bool ModifyView::_internal_has_definer() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ModifyView::has_definer() const {
  return _internal_has_definer();
}
inline void ModifyView::clear_definer() {
  definer_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ModifyView::definer() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.ModifyView.definer)
  return _internal_definer();
}
inline void ModifyView::set_definer(const std::string& value) {
  _internal_set_definer(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.ModifyView.definer)
}
inline std::string* ModifyView::mutable_definer() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.ModifyView.definer)
  return _internal_mutable_definer();
}
inline const std::string& ModifyView::_internal_definer() const {
  return definer_.GetNoArena();
}
inline void ModifyView::_internal_set_definer(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  definer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ModifyView::set_definer(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  definer_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Mysqlx.Crud.ModifyView.definer)
}
inline void ModifyView::set_definer(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  definer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.ModifyView.definer)
}
inline void ModifyView::set_definer(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  definer_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.ModifyView.definer)
}
inline std::string* ModifyView::_internal_mutable_definer() {
  _has_bits_[0] |= 0x00000001u;
  return definer_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ModifyView::release_definer() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.ModifyView.definer)
  if (!_internal_has_definer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return definer_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ModifyView::set_allocated_definer(std::string* definer) {
  if (definer != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  definer_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), definer);
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.ModifyView.definer)
}

// optional .Mysqlx.Crud.ViewAlgorithm algorithm = 3;
inline bool ModifyView::_internal_has_algorithm() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ModifyView::has_algorithm() const {
  return _internal_has_algorithm();
}
inline void ModifyView::clear_algorithm() {
  algorithm_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::Mysqlx::Crud::ViewAlgorithm ModifyView::_internal_algorithm() const {
  return static_cast< ::Mysqlx::Crud::ViewAlgorithm >(algorithm_);
}
inline ::Mysqlx::Crud::ViewAlgorithm ModifyView::algorithm() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.ModifyView.algorithm)
  return _internal_algorithm();
}
inline void ModifyView::_internal_set_algorithm(::Mysqlx::Crud::ViewAlgorithm value) {
  assert(::Mysqlx::Crud::ViewAlgorithm_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  algorithm_ = value;
}
inline void ModifyView::set_algorithm(::Mysqlx::Crud::ViewAlgorithm value) {
  _internal_set_algorithm(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.ModifyView.algorithm)
}

// optional .Mysqlx.Crud.ViewSqlSecurity security = 4;
inline bool ModifyView::_internal_has_security() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ModifyView::has_security() const {
  return _internal_has_security();
}
inline void ModifyView::clear_security() {
  security_ = 1;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::Mysqlx::Crud::ViewSqlSecurity ModifyView::_internal_security() const {
  return static_cast< ::Mysqlx::Crud::ViewSqlSecurity >(security_);
}
inline ::Mysqlx::Crud::ViewSqlSecurity ModifyView::security() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.ModifyView.security)
  return _internal_security();
}
inline void ModifyView::_internal_set_security(::Mysqlx::Crud::ViewSqlSecurity value) {
  assert(::Mysqlx::Crud::ViewSqlSecurity_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  security_ = value;
}
inline void ModifyView::set_security(::Mysqlx::Crud::ViewSqlSecurity value) {
  _internal_set_security(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.ModifyView.security)
}

// optional .Mysqlx.Crud.ViewCheckOption check = 5;
inline bool ModifyView::_internal_has_check() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ModifyView::has_check() const {
  return _internal_has_check();
}
inline void ModifyView::clear_check() {
  check_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::Mysqlx::Crud::ViewCheckOption ModifyView::_internal_check() const {
  return static_cast< ::Mysqlx::Crud::ViewCheckOption >(check_);
}
inline ::Mysqlx::Crud::ViewCheckOption ModifyView::check() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.ModifyView.check)
  return _internal_check();
}
inline void ModifyView::_internal_set_check(::Mysqlx::Crud::ViewCheckOption value) {
  assert(::Mysqlx::Crud::ViewCheckOption_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  check_ = value;
}
inline void ModifyView::set_check(::Mysqlx::Crud::ViewCheckOption value) {
  _internal_set_check(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.ModifyView.check)
}

// repeated string column = 6;
inline int ModifyView::_internal_column_size() const {
  return column_.size();
}
inline int ModifyView::column_size() const {
  return _internal_column_size();
}
inline void ModifyView::clear_column() {
  column_.Clear();
}
inline std::string* ModifyView::add_column() {
  // @@protoc_insertion_point(field_add_mutable:Mysqlx.Crud.ModifyView.column)
  return _internal_add_column();
}
inline const std::string& ModifyView::_internal_column(int index) const {
  return column_.Get(index);
}
inline const std::string& ModifyView::column(int index) const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.ModifyView.column)
  return _internal_column(index);
}
inline std::string* ModifyView::mutable_column(int index) {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.ModifyView.column)
  return column_.Mutable(index);
}
inline void ModifyView::set_column(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.ModifyView.column)
  column_.Mutable(index)->assign(value);
}
inline void ModifyView::set_column(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.ModifyView.column)
  column_.Mutable(index)->assign(std::move(value));
}
inline void ModifyView::set_column(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  column_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Mysqlx.Crud.ModifyView.column)
}
inline void ModifyView::set_column(int index, const char* value, size_t size) {
  column_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Mysqlx.Crud.ModifyView.column)
}
inline std::string* ModifyView::_internal_add_column() {
  return column_.Add();
}
inline void ModifyView::add_column(const std::string& value) {
  column_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.ModifyView.column)
}
inline void ModifyView::add_column(std::string&& value) {
  column_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Mysqlx.Crud.ModifyView.column)
}
inline void ModifyView::add_column(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  column_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Mysqlx.Crud.ModifyView.column)
}
inline void ModifyView::add_column(const char* value, size_t size) {
  column_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Mysqlx.Crud.ModifyView.column)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModifyView::column() const {
  // @@protoc_insertion_point(field_list:Mysqlx.Crud.ModifyView.column)
  return column_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModifyView::mutable_column() {
  // @@protoc_insertion_point(field_mutable_list:Mysqlx.Crud.ModifyView.column)
  return &column_;
}

// optional .Mysqlx.Crud.Find stmt = 7;
inline bool ModifyView::_internal_has_stmt() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || stmt_ != nullptr);
  return value;
}
inline bool ModifyView::has_stmt() const {
  return _internal_has_stmt();
}
inline void ModifyView::clear_stmt() {
  if (stmt_ != nullptr) stmt_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::Mysqlx::Crud::Find& ModifyView::_internal_stmt() const {
  const ::Mysqlx::Crud::Find* p = stmt_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Crud::Find*>(
      &::Mysqlx::Crud::_Find_default_instance_);
}
inline const ::Mysqlx::Crud::Find& ModifyView::stmt() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.ModifyView.stmt)
  return _internal_stmt();
}
inline ::Mysqlx::Crud::Find* ModifyView::release_stmt() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.ModifyView.stmt)
  _has_bits_[0] &= ~0x00000004u;
  ::Mysqlx::Crud::Find* temp = stmt_;
  stmt_ = nullptr;
  return temp;
}
inline ::Mysqlx::Crud::Find* ModifyView::_internal_mutable_stmt() {
  _has_bits_[0] |= 0x00000004u;
  if (stmt_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::Find>(GetArenaNoVirtual());
    stmt_ = p;
  }
  return stmt_;
}
inline ::Mysqlx::Crud::Find* ModifyView::mutable_stmt() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.ModifyView.stmt)
  return _internal_mutable_stmt();
}
inline void ModifyView::set_allocated_stmt(::Mysqlx::Crud::Find* stmt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete stmt_;
  }
  if (stmt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      stmt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stmt, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  stmt_ = stmt;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.ModifyView.stmt)
}

// -------------------------------------------------------------------

// DropView

// required .Mysqlx.Crud.Collection collection = 1;
inline bool DropView::_internal_has_collection() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || collection_ != nullptr);
  return value;
}
inline bool DropView::has_collection() const {
  return _internal_has_collection();
}
inline void DropView::clear_collection() {
  if (collection_ != nullptr) collection_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Mysqlx::Crud::Collection& DropView::_internal_collection() const {
  const ::Mysqlx::Crud::Collection* p = collection_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Mysqlx::Crud::Collection*>(
      &::Mysqlx::Crud::_Collection_default_instance_);
}
inline const ::Mysqlx::Crud::Collection& DropView::collection() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.DropView.collection)
  return _internal_collection();
}
inline ::Mysqlx::Crud::Collection* DropView::release_collection() {
  // @@protoc_insertion_point(field_release:Mysqlx.Crud.DropView.collection)
  _has_bits_[0] &= ~0x00000001u;
  ::Mysqlx::Crud::Collection* temp = collection_;
  collection_ = nullptr;
  return temp;
}
inline ::Mysqlx::Crud::Collection* DropView::_internal_mutable_collection() {
  _has_bits_[0] |= 0x00000001u;
  if (collection_ == nullptr) {
    auto* p = CreateMaybeMessage<::Mysqlx::Crud::Collection>(GetArenaNoVirtual());
    collection_ = p;
  }
  return collection_;
}
inline ::Mysqlx::Crud::Collection* DropView::mutable_collection() {
  // @@protoc_insertion_point(field_mutable:Mysqlx.Crud.DropView.collection)
  return _internal_mutable_collection();
}
inline void DropView::set_allocated_collection(::Mysqlx::Crud::Collection* collection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete collection_;
  }
  if (collection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      collection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, collection, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  collection_ = collection;
  // @@protoc_insertion_point(field_set_allocated:Mysqlx.Crud.DropView.collection)
}

// optional bool if_exists = 2 [default = false];
inline bool DropView::_internal_has_if_exists() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DropView::has_if_exists() const {
  return _internal_has_if_exists();
}
inline void DropView::clear_if_exists() {
  if_exists_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool DropView::_internal_if_exists() const {
  return if_exists_;
}
inline bool DropView::if_exists() const {
  // @@protoc_insertion_point(field_get:Mysqlx.Crud.DropView.if_exists)
  return _internal_if_exists();
}
inline void DropView::_internal_set_if_exists(bool value) {
  _has_bits_[0] |= 0x00000002u;
  if_exists_ = value;
}
inline void DropView::set_if_exists(bool value) {
  _internal_set_if_exists(value);
  // @@protoc_insertion_point(field_set:Mysqlx.Crud.DropView.if_exists)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Crud
}  // namespace Mysqlx

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Mysqlx::Crud::Order_Direction> : ::std::true_type {};
template <> struct is_proto_enum< ::Mysqlx::Crud::UpdateOperation_UpdateType> : ::std::true_type {};
template <> struct is_proto_enum< ::Mysqlx::Crud::Find_RowLock> : ::std::true_type {};
template <> struct is_proto_enum< ::Mysqlx::Crud::Find_RowLockOptions> : ::std::true_type {};
template <> struct is_proto_enum< ::Mysqlx::Crud::DataModel> : ::std::true_type {};
template <> struct is_proto_enum< ::Mysqlx::Crud::ViewAlgorithm> : ::std::true_type {};
template <> struct is_proto_enum< ::Mysqlx::Crud::ViewSqlSecurity> : ::std::true_type {};
template <> struct is_proto_enum< ::Mysqlx::Crud::ViewCheckOption> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mysqlx_5fcrud_2eproto
