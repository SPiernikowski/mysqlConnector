// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mysqlx_crud.proto

#include "mysqlx_crud.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_mysqlx_5fcrud_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Collection_mysqlx_5fcrud_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mysqlx_5fcrud_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Column_mysqlx_5fcrud_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mysqlx_5fcrud_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<7> scc_info_Find_mysqlx_5fcrud_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mysqlx_5fcrud_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Insert_TypedRow_mysqlx_5fcrud_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mysqlx_5fcrud_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Limit_mysqlx_5fcrud_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mysqlx_5fcrud_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_LimitExpr_mysqlx_5fcrud_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mysqlx_5fcrud_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Order_mysqlx_5fcrud_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mysqlx_5fcrud_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Projection_mysqlx_5fcrud_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mysqlx_5fcrud_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UpdateOperation_mysqlx_5fcrud_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mysqlx_5fdatatypes_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_Scalar_mysqlx_5fdatatypes_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mysqlx_5fexpr_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_Array_mysqlx_5fexpr_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mysqlx_5fexpr_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ColumnIdentifier_mysqlx_5fexpr_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_mysqlx_5fexpr_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_DocumentPathItem_mysqlx_5fexpr_2eproto;
namespace Mysqlx {
namespace Crud {
class ColumnDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Column> _instance;
} _Column_default_instance_;
class ProjectionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Projection> _instance;
} _Projection_default_instance_;
class CollectionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Collection> _instance;
} _Collection_default_instance_;
class LimitDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Limit> _instance;
} _Limit_default_instance_;
class LimitExprDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<LimitExpr> _instance;
} _LimitExpr_default_instance_;
class OrderDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Order> _instance;
} _Order_default_instance_;
class UpdateOperationDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UpdateOperation> _instance;
} _UpdateOperation_default_instance_;
class FindDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Find> _instance;
} _Find_default_instance_;
class Insert_TypedRowDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Insert_TypedRow> _instance;
} _Insert_TypedRow_default_instance_;
class InsertDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Insert> _instance;
} _Insert_default_instance_;
class UpdateDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Update> _instance;
} _Update_default_instance_;
class DeleteDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Delete> _instance;
} _Delete_default_instance_;
class CreateViewDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CreateView> _instance;
} _CreateView_default_instance_;
class ModifyViewDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ModifyView> _instance;
} _ModifyView_default_instance_;
class DropViewDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<DropView> _instance;
} _DropView_default_instance_;
}  // namespace Crud
}  // namespace Mysqlx
static void InitDefaultsscc_info_Collection_mysqlx_5fcrud_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Collection_default_instance_;
    new (ptr) ::Mysqlx::Crud::Collection();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Collection::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Collection_mysqlx_5fcrud_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Collection_mysqlx_5fcrud_2eproto}, {}};

static void InitDefaultsscc_info_Column_mysqlx_5fcrud_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Column_default_instance_;
    new (ptr) ::Mysqlx::Crud::Column();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Column::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Column_mysqlx_5fcrud_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_Column_mysqlx_5fcrud_2eproto}, {
      &scc_info_DocumentPathItem_mysqlx_5fexpr_2eproto.base,}};

static void InitDefaultsscc_info_CreateView_mysqlx_5fcrud_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_CreateView_default_instance_;
    new (ptr) ::Mysqlx::Crud::CreateView();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::CreateView::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_CreateView_mysqlx_5fcrud_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_CreateView_mysqlx_5fcrud_2eproto}, {
      &scc_info_Collection_mysqlx_5fcrud_2eproto.base,
      &scc_info_Find_mysqlx_5fcrud_2eproto.base,}};

static void InitDefaultsscc_info_Delete_mysqlx_5fcrud_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Delete_default_instance_;
    new (ptr) ::Mysqlx::Crud::Delete();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Delete::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<6> scc_info_Delete_mysqlx_5fcrud_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 6, 0, InitDefaultsscc_info_Delete_mysqlx_5fcrud_2eproto}, {
      &scc_info_Collection_mysqlx_5fcrud_2eproto.base,
      &scc_info_Array_mysqlx_5fexpr_2eproto.base,
      &scc_info_Scalar_mysqlx_5fdatatypes_2eproto.base,
      &scc_info_Order_mysqlx_5fcrud_2eproto.base,
      &scc_info_Limit_mysqlx_5fcrud_2eproto.base,
      &scc_info_LimitExpr_mysqlx_5fcrud_2eproto.base,}};

static void InitDefaultsscc_info_DropView_mysqlx_5fcrud_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_DropView_default_instance_;
    new (ptr) ::Mysqlx::Crud::DropView();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::DropView::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_DropView_mysqlx_5fcrud_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_DropView_mysqlx_5fcrud_2eproto}, {
      &scc_info_Collection_mysqlx_5fcrud_2eproto.base,}};

static void InitDefaultsscc_info_Find_mysqlx_5fcrud_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Find_default_instance_;
    new (ptr) ::Mysqlx::Crud::Find();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Find::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<7> scc_info_Find_mysqlx_5fcrud_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 7, 0, InitDefaultsscc_info_Find_mysqlx_5fcrud_2eproto}, {
      &scc_info_Collection_mysqlx_5fcrud_2eproto.base,
      &scc_info_Projection_mysqlx_5fcrud_2eproto.base,
      &scc_info_Array_mysqlx_5fexpr_2eproto.base,
      &scc_info_Scalar_mysqlx_5fdatatypes_2eproto.base,
      &scc_info_Order_mysqlx_5fcrud_2eproto.base,
      &scc_info_Limit_mysqlx_5fcrud_2eproto.base,
      &scc_info_LimitExpr_mysqlx_5fcrud_2eproto.base,}};

static void InitDefaultsscc_info_Insert_mysqlx_5fcrud_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Insert_default_instance_;
    new (ptr) ::Mysqlx::Crud::Insert();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Insert::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_Insert_mysqlx_5fcrud_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 4, 0, InitDefaultsscc_info_Insert_mysqlx_5fcrud_2eproto}, {
      &scc_info_Collection_mysqlx_5fcrud_2eproto.base,
      &scc_info_Column_mysqlx_5fcrud_2eproto.base,
      &scc_info_Insert_TypedRow_mysqlx_5fcrud_2eproto.base,
      &scc_info_Scalar_mysqlx_5fdatatypes_2eproto.base,}};

static void InitDefaultsscc_info_Insert_TypedRow_mysqlx_5fcrud_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Insert_TypedRow_default_instance_;
    new (ptr) ::Mysqlx::Crud::Insert_TypedRow();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Insert_TypedRow::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Insert_TypedRow_mysqlx_5fcrud_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_Insert_TypedRow_mysqlx_5fcrud_2eproto}, {
      &scc_info_Array_mysqlx_5fexpr_2eproto.base,}};

static void InitDefaultsscc_info_Limit_mysqlx_5fcrud_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Limit_default_instance_;
    new (ptr) ::Mysqlx::Crud::Limit();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Limit::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Limit_mysqlx_5fcrud_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Limit_mysqlx_5fcrud_2eproto}, {}};

static void InitDefaultsscc_info_LimitExpr_mysqlx_5fcrud_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_LimitExpr_default_instance_;
    new (ptr) ::Mysqlx::Crud::LimitExpr();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::LimitExpr::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_LimitExpr_mysqlx_5fcrud_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_LimitExpr_mysqlx_5fcrud_2eproto}, {
      &scc_info_Array_mysqlx_5fexpr_2eproto.base,}};

static void InitDefaultsscc_info_ModifyView_mysqlx_5fcrud_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_ModifyView_default_instance_;
    new (ptr) ::Mysqlx::Crud::ModifyView();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::ModifyView::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_ModifyView_mysqlx_5fcrud_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_ModifyView_mysqlx_5fcrud_2eproto}, {
      &scc_info_Collection_mysqlx_5fcrud_2eproto.base,
      &scc_info_Find_mysqlx_5fcrud_2eproto.base,}};

static void InitDefaultsscc_info_Order_mysqlx_5fcrud_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Order_default_instance_;
    new (ptr) ::Mysqlx::Crud::Order();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Order::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Order_mysqlx_5fcrud_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_Order_mysqlx_5fcrud_2eproto}, {
      &scc_info_Array_mysqlx_5fexpr_2eproto.base,}};

static void InitDefaultsscc_info_Projection_mysqlx_5fcrud_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Projection_default_instance_;
    new (ptr) ::Mysqlx::Crud::Projection();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Projection::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Projection_mysqlx_5fcrud_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_Projection_mysqlx_5fcrud_2eproto}, {
      &scc_info_Array_mysqlx_5fexpr_2eproto.base,}};

static void InitDefaultsscc_info_Update_mysqlx_5fcrud_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_Update_default_instance_;
    new (ptr) ::Mysqlx::Crud::Update();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::Update::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<7> scc_info_Update_mysqlx_5fcrud_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 7, 0, InitDefaultsscc_info_Update_mysqlx_5fcrud_2eproto}, {
      &scc_info_Collection_mysqlx_5fcrud_2eproto.base,
      &scc_info_Array_mysqlx_5fexpr_2eproto.base,
      &scc_info_Scalar_mysqlx_5fdatatypes_2eproto.base,
      &scc_info_Order_mysqlx_5fcrud_2eproto.base,
      &scc_info_UpdateOperation_mysqlx_5fcrud_2eproto.base,
      &scc_info_Limit_mysqlx_5fcrud_2eproto.base,
      &scc_info_LimitExpr_mysqlx_5fcrud_2eproto.base,}};

static void InitDefaultsscc_info_UpdateOperation_mysqlx_5fcrud_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Mysqlx::Crud::_UpdateOperation_default_instance_;
    new (ptr) ::Mysqlx::Crud::UpdateOperation();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Mysqlx::Crud::UpdateOperation::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UpdateOperation_mysqlx_5fcrud_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_UpdateOperation_mysqlx_5fcrud_2eproto}, {
      &scc_info_ColumnIdentifier_mysqlx_5fexpr_2eproto.base,
      &scc_info_Array_mysqlx_5fexpr_2eproto.base,}};

namespace Mysqlx {
namespace Crud {
bool Order_Direction_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Order_Direction_strings[2] = {};

static const char Order_Direction_names[] =
  "ASC"
  "DESC";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Order_Direction_entries[] = {
  { {Order_Direction_names + 0, 3}, 1 },
  { {Order_Direction_names + 3, 4}, 2 },
};

static const int Order_Direction_entries_by_number[] = {
  0, // 1 -> ASC
  1, // 2 -> DESC
};

const std::string& Order_Direction_Name(
    Order_Direction value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Order_Direction_entries,
          Order_Direction_entries_by_number,
          2, Order_Direction_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Order_Direction_entries,
      Order_Direction_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Order_Direction_strings[idx].get();
}
bool Order_Direction_Parse(
    const std::string& name, Order_Direction* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Order_Direction_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<Order_Direction>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Order_Direction Order::ASC;
constexpr Order_Direction Order::DESC;
constexpr Order_Direction Order::Direction_MIN;
constexpr Order_Direction Order::Direction_MAX;
constexpr int Order::Direction_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool UpdateOperation_UpdateType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UpdateOperation_UpdateType_strings[8] = {};

static const char UpdateOperation_UpdateType_names[] =
  "ARRAY_APPEND"
  "ARRAY_INSERT"
  "ITEM_MERGE"
  "ITEM_REMOVE"
  "ITEM_REPLACE"
  "ITEM_SET"
  "MERGE_PATCH"
  "SET";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UpdateOperation_UpdateType_entries[] = {
  { {UpdateOperation_UpdateType_names + 0, 12}, 7 },
  { {UpdateOperation_UpdateType_names + 12, 12}, 6 },
  { {UpdateOperation_UpdateType_names + 24, 10}, 5 },
  { {UpdateOperation_UpdateType_names + 34, 11}, 2 },
  { {UpdateOperation_UpdateType_names + 45, 12}, 4 },
  { {UpdateOperation_UpdateType_names + 57, 8}, 3 },
  { {UpdateOperation_UpdateType_names + 65, 11}, 8 },
  { {UpdateOperation_UpdateType_names + 76, 3}, 1 },
};

static const int UpdateOperation_UpdateType_entries_by_number[] = {
  7, // 1 -> SET
  3, // 2 -> ITEM_REMOVE
  5, // 3 -> ITEM_SET
  4, // 4 -> ITEM_REPLACE
  2, // 5 -> ITEM_MERGE
  1, // 6 -> ARRAY_INSERT
  0, // 7 -> ARRAY_APPEND
  6, // 8 -> MERGE_PATCH
};

const std::string& UpdateOperation_UpdateType_Name(
    UpdateOperation_UpdateType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          UpdateOperation_UpdateType_entries,
          UpdateOperation_UpdateType_entries_by_number,
          8, UpdateOperation_UpdateType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      UpdateOperation_UpdateType_entries,
      UpdateOperation_UpdateType_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     UpdateOperation_UpdateType_strings[idx].get();
}
bool UpdateOperation_UpdateType_Parse(
    const std::string& name, UpdateOperation_UpdateType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      UpdateOperation_UpdateType_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<UpdateOperation_UpdateType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr UpdateOperation_UpdateType UpdateOperation::SET;
constexpr UpdateOperation_UpdateType UpdateOperation::ITEM_REMOVE;
constexpr UpdateOperation_UpdateType UpdateOperation::ITEM_SET;
constexpr UpdateOperation_UpdateType UpdateOperation::ITEM_REPLACE;
constexpr UpdateOperation_UpdateType UpdateOperation::ITEM_MERGE;
constexpr UpdateOperation_UpdateType UpdateOperation::ARRAY_INSERT;
constexpr UpdateOperation_UpdateType UpdateOperation::ARRAY_APPEND;
constexpr UpdateOperation_UpdateType UpdateOperation::MERGE_PATCH;
constexpr UpdateOperation_UpdateType UpdateOperation::UpdateType_MIN;
constexpr UpdateOperation_UpdateType UpdateOperation::UpdateType_MAX;
constexpr int UpdateOperation::UpdateType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool Find_RowLock_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Find_RowLock_strings[2] = {};

static const char Find_RowLock_names[] =
  "EXCLUSIVE_LOCK"
  "SHARED_LOCK";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Find_RowLock_entries[] = {
  { {Find_RowLock_names + 0, 14}, 2 },
  { {Find_RowLock_names + 14, 11}, 1 },
};

static const int Find_RowLock_entries_by_number[] = {
  1, // 1 -> SHARED_LOCK
  0, // 2 -> EXCLUSIVE_LOCK
};

const std::string& Find_RowLock_Name(
    Find_RowLock value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Find_RowLock_entries,
          Find_RowLock_entries_by_number,
          2, Find_RowLock_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Find_RowLock_entries,
      Find_RowLock_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Find_RowLock_strings[idx].get();
}
bool Find_RowLock_Parse(
    const std::string& name, Find_RowLock* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Find_RowLock_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<Find_RowLock>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Find_RowLock Find::SHARED_LOCK;
constexpr Find_RowLock Find::EXCLUSIVE_LOCK;
constexpr Find_RowLock Find::RowLock_MIN;
constexpr Find_RowLock Find::RowLock_MAX;
constexpr int Find::RowLock_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool Find_RowLockOptions_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Find_RowLockOptions_strings[2] = {};

static const char Find_RowLockOptions_names[] =
  "NOWAIT"
  "SKIP_LOCKED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Find_RowLockOptions_entries[] = {
  { {Find_RowLockOptions_names + 0, 6}, 1 },
  { {Find_RowLockOptions_names + 6, 11}, 2 },
};

static const int Find_RowLockOptions_entries_by_number[] = {
  0, // 1 -> NOWAIT
  1, // 2 -> SKIP_LOCKED
};

const std::string& Find_RowLockOptions_Name(
    Find_RowLockOptions value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Find_RowLockOptions_entries,
          Find_RowLockOptions_entries_by_number,
          2, Find_RowLockOptions_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Find_RowLockOptions_entries,
      Find_RowLockOptions_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Find_RowLockOptions_strings[idx].get();
}
bool Find_RowLockOptions_Parse(
    const std::string& name, Find_RowLockOptions* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Find_RowLockOptions_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<Find_RowLockOptions>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Find_RowLockOptions Find::NOWAIT;
constexpr Find_RowLockOptions Find::SKIP_LOCKED;
constexpr Find_RowLockOptions Find::RowLockOptions_MIN;
constexpr Find_RowLockOptions Find::RowLockOptions_MAX;
constexpr int Find::RowLockOptions_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool DataModel_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DataModel_strings[2] = {};

static const char DataModel_names[] =
  "DOCUMENT"
  "TABLE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DataModel_entries[] = {
  { {DataModel_names + 0, 8}, 1 },
  { {DataModel_names + 8, 5}, 2 },
};

static const int DataModel_entries_by_number[] = {
  0, // 1 -> DOCUMENT
  1, // 2 -> TABLE
};

const std::string& DataModel_Name(
    DataModel value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DataModel_entries,
          DataModel_entries_by_number,
          2, DataModel_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DataModel_entries,
      DataModel_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DataModel_strings[idx].get();
}
bool DataModel_Parse(
    const std::string& name, DataModel* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DataModel_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<DataModel>(int_value);
  }
  return success;
}
bool ViewAlgorithm_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ViewAlgorithm_strings[3] = {};

static const char ViewAlgorithm_names[] =
  "MERGE"
  "TEMPTABLE"
  "UNDEFINED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ViewAlgorithm_entries[] = {
  { {ViewAlgorithm_names + 0, 5}, 2 },
  { {ViewAlgorithm_names + 5, 9}, 3 },
  { {ViewAlgorithm_names + 14, 9}, 1 },
};

static const int ViewAlgorithm_entries_by_number[] = {
  2, // 1 -> UNDEFINED
  0, // 2 -> MERGE
  1, // 3 -> TEMPTABLE
};

const std::string& ViewAlgorithm_Name(
    ViewAlgorithm value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ViewAlgorithm_entries,
          ViewAlgorithm_entries_by_number,
          3, ViewAlgorithm_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ViewAlgorithm_entries,
      ViewAlgorithm_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ViewAlgorithm_strings[idx].get();
}
bool ViewAlgorithm_Parse(
    const std::string& name, ViewAlgorithm* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ViewAlgorithm_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ViewAlgorithm>(int_value);
  }
  return success;
}
bool ViewSqlSecurity_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ViewSqlSecurity_strings[2] = {};

static const char ViewSqlSecurity_names[] =
  "DEFINER"
  "INVOKER";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ViewSqlSecurity_entries[] = {
  { {ViewSqlSecurity_names + 0, 7}, 2 },
  { {ViewSqlSecurity_names + 7, 7}, 1 },
};

static const int ViewSqlSecurity_entries_by_number[] = {
  1, // 1 -> INVOKER
  0, // 2 -> DEFINER
};

const std::string& ViewSqlSecurity_Name(
    ViewSqlSecurity value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ViewSqlSecurity_entries,
          ViewSqlSecurity_entries_by_number,
          2, ViewSqlSecurity_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ViewSqlSecurity_entries,
      ViewSqlSecurity_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ViewSqlSecurity_strings[idx].get();
}
bool ViewSqlSecurity_Parse(
    const std::string& name, ViewSqlSecurity* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ViewSqlSecurity_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<ViewSqlSecurity>(int_value);
  }
  return success;
}
bool ViewCheckOption_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ViewCheckOption_strings[2] = {};

static const char ViewCheckOption_names[] =
  "CASCADED"
  "LOCAL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ViewCheckOption_entries[] = {
  { {ViewCheckOption_names + 0, 8}, 2 },
  { {ViewCheckOption_names + 8, 5}, 1 },
};

static const int ViewCheckOption_entries_by_number[] = {
  1, // 1 -> LOCAL
  0, // 2 -> CASCADED
};

const std::string& ViewCheckOption_Name(
    ViewCheckOption value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ViewCheckOption_entries,
          ViewCheckOption_entries_by_number,
          2, ViewCheckOption_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ViewCheckOption_entries,
      ViewCheckOption_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ViewCheckOption_strings[idx].get();
}
bool ViewCheckOption_Parse(
    const std::string& name, ViewCheckOption* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ViewCheckOption_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<ViewCheckOption>(int_value);
  }
  return success;
}

// ===================================================================

void Column::InitAsDefaultInstance() {
}
class Column::_Internal {
 public:
  using HasBits = decltype(std::declval<Column>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_alias(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

void Column::clear_document_path() {
  document_path_.Clear();
}
Column::Column()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Column)
}
Column::Column(const Column& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      document_path_(from.document_path_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  alias_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_alias()) {
    alias_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.alias_);
  }
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Column)
}

void Column::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Column_mysqlx_5fcrud_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  alias_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

Column::~Column() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Column)
  SharedDtor();
}

void Column::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  alias_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Column::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Column& Column::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Column_mysqlx_5fcrud_2eproto.base);
  return *internal_default_instance();
}


void Column::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Column)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  document_path_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      alias_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Column::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string alias = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_alias();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_document_path(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Column::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Column)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string alias = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_alias(), target);
  }

  // repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_document_path_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_document_path(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Column)
  return target;
}

size_t Column::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Column)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Mysqlx.Expr.DocumentPathItem document_path = 3;
  total_size += 1UL * this->_internal_document_path_size();
  for (const auto& msg : this->document_path_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string alias = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_alias());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Column::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Column*>(
      &from));
}

void Column::MergeFrom(const Column& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Column)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  document_path_.MergeFrom(from.document_path_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      alias_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.alias_);
    }
  }
}

void Column::CopyFrom(const Column& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Column)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Column::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(document_path_)) return false;
  return true;
}

void Column::InternalSwap(Column* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  document_path_.InternalSwap(&other->document_path_);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  alias_.Swap(&other->alias_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

std::string Column::GetTypeName() const {
  return "Mysqlx.Crud.Column";
}


// ===================================================================

void Projection::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_Projection_default_instance_._instance.get_mutable()->source_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
}
class Projection::_Internal {
 public:
  using HasBits = decltype(std::declval<Projection>()._has_bits_);
  static const ::Mysqlx::Expr::Expr& source(const Projection* msg);
  static void set_has_source(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_alias(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::Mysqlx::Expr::Expr&
Projection::_Internal::source(const Projection* msg) {
  return *msg->source_;
}
void Projection::clear_source() {
  if (source_ != nullptr) source_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
Projection::Projection()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Projection)
}
Projection::Projection(const Projection& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  alias_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_alias()) {
    alias_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.alias_);
  }
  if (from._internal_has_source()) {
    source_ = new ::Mysqlx::Expr::Expr(*from.source_);
  } else {
    source_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Projection)
}

void Projection::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Projection_mysqlx_5fcrud_2eproto.base);
  alias_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  source_ = nullptr;
}

Projection::~Projection() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Projection)
  SharedDtor();
}

void Projection::SharedDtor() {
  alias_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete source_;
}

void Projection::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Projection& Projection::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Projection_mysqlx_5fcrud_2eproto.base);
  return *internal_default_instance();
}


void Projection::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Projection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      alias_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(source_ != nullptr);
      source_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Projection::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .Mysqlx.Expr.Expr source = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_source(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string alias = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_alias();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Projection::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Projection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Expr.Expr source = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::source(this), target, stream);
  }

  // optional string alias = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_alias(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Projection)
  return target;
}

size_t Projection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Projection)
  size_t total_size = 0;

  // required .Mysqlx.Expr.Expr source = 1;
  if (_internal_has_source()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *source_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string alias = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_alias());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Projection::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Projection*>(
      &from));
}

void Projection::MergeFrom(const Projection& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Projection)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      alias_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.alias_);
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_source()->::Mysqlx::Expr::Expr::MergeFrom(from._internal_source());
    }
  }
}

void Projection::CopyFrom(const Projection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Projection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Projection::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  if (_internal_has_source()) {
    if (!source_->IsInitialized()) return false;
  }
  return true;
}

void Projection::InternalSwap(Projection* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  alias_.Swap(&other->alias_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(source_, other->source_);
}

std::string Projection::GetTypeName() const {
  return "Mysqlx.Crud.Projection";
}


// ===================================================================

void Collection::InitAsDefaultInstance() {
}
class Collection::_Internal {
 public:
  using HasBits = decltype(std::declval<Collection>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_schema(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Collection::Collection()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Collection)
}
Collection::Collection(const Collection& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  schema_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_schema()) {
    schema_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.schema_);
  }
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Collection)
}

void Collection::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Collection_mysqlx_5fcrud_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  schema_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

Collection::~Collection() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Collection)
  SharedDtor();
}

void Collection::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  schema_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Collection::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Collection& Collection::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Collection_mysqlx_5fcrud_2eproto.base);
  return *internal_default_instance();
}


void Collection::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Collection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      schema_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Collection::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string schema = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_schema();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Collection::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Collection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string schema = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_schema(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Collection)
  return target;
}

size_t Collection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Collection)
  size_t total_size = 0;

  // required string name = 1;
  if (_internal_has_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string schema = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_schema());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Collection::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Collection*>(
      &from));
}

void Collection::MergeFrom(const Collection& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Collection)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      schema_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.schema_);
    }
  }
}

void Collection::CopyFrom(const Collection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Collection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Collection::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void Collection::InternalSwap(Collection* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  schema_.Swap(&other->schema_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

std::string Collection::GetTypeName() const {
  return "Mysqlx.Crud.Collection";
}


// ===================================================================

void Limit::InitAsDefaultInstance() {
}
class Limit::_Internal {
 public:
  using HasBits = decltype(std::declval<Limit>()._has_bits_);
  static void set_has_row_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Limit::Limit()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Limit)
}
Limit::Limit(const Limit& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&row_count_, &from.row_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&offset_) -
    reinterpret_cast<char*>(&row_count_)) + sizeof(offset_));
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Limit)
}

void Limit::SharedCtor() {
  ::memset(&row_count_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&offset_) -
      reinterpret_cast<char*>(&row_count_)) + sizeof(offset_));
}

Limit::~Limit() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Limit)
  SharedDtor();
}

void Limit::SharedDtor() {
}

void Limit::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Limit& Limit::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Limit_mysqlx_5fcrud_2eproto.base);
  return *internal_default_instance();
}


void Limit::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Limit)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&row_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&offset_) -
        reinterpret_cast<char*>(&row_count_)) + sizeof(offset_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Limit::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint64 row_count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_row_count(&has_bits);
          row_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Limit::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Limit)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 row_count = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_row_count(), target);
  }

  // optional uint64 offset = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_offset(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Limit)
  return target;
}

size_t Limit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Limit)
  size_t total_size = 0;

  // required uint64 row_count = 1;
  if (_internal_has_row_count()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_row_count());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 offset = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_offset());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Limit::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Limit*>(
      &from));
}

void Limit::MergeFrom(const Limit& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Limit)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      row_count_ = from.row_count_;
    }
    if (cached_has_bits & 0x00000002u) {
      offset_ = from.offset_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Limit::CopyFrom(const Limit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Limit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Limit::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void Limit::InternalSwap(Limit* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(row_count_, other->row_count_);
  swap(offset_, other->offset_);
}

std::string Limit::GetTypeName() const {
  return "Mysqlx.Crud.Limit";
}


// ===================================================================

void LimitExpr::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_LimitExpr_default_instance_._instance.get_mutable()->row_count_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
  ::Mysqlx::Crud::_LimitExpr_default_instance_._instance.get_mutable()->offset_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
}
class LimitExpr::_Internal {
 public:
  using HasBits = decltype(std::declval<LimitExpr>()._has_bits_);
  static const ::Mysqlx::Expr::Expr& row_count(const LimitExpr* msg);
  static void set_has_row_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::Mysqlx::Expr::Expr& offset(const LimitExpr* msg);
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::Mysqlx::Expr::Expr&
LimitExpr::_Internal::row_count(const LimitExpr* msg) {
  return *msg->row_count_;
}
const ::Mysqlx::Expr::Expr&
LimitExpr::_Internal::offset(const LimitExpr* msg) {
  return *msg->offset_;
}
void LimitExpr::clear_row_count() {
  if (row_count_ != nullptr) row_count_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void LimitExpr::clear_offset() {
  if (offset_ != nullptr) offset_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
LimitExpr::LimitExpr()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.LimitExpr)
}
LimitExpr::LimitExpr(const LimitExpr& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_row_count()) {
    row_count_ = new ::Mysqlx::Expr::Expr(*from.row_count_);
  } else {
    row_count_ = nullptr;
  }
  if (from._internal_has_offset()) {
    offset_ = new ::Mysqlx::Expr::Expr(*from.offset_);
  } else {
    offset_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.LimitExpr)
}

void LimitExpr::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_LimitExpr_mysqlx_5fcrud_2eproto.base);
  ::memset(&row_count_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&offset_) -
      reinterpret_cast<char*>(&row_count_)) + sizeof(offset_));
}

LimitExpr::~LimitExpr() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.LimitExpr)
  SharedDtor();
}

void LimitExpr::SharedDtor() {
  if (this != internal_default_instance()) delete row_count_;
  if (this != internal_default_instance()) delete offset_;
}

void LimitExpr::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LimitExpr& LimitExpr::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_LimitExpr_mysqlx_5fcrud_2eproto.base);
  return *internal_default_instance();
}


void LimitExpr::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.LimitExpr)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(row_count_ != nullptr);
      row_count_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(offset_ != nullptr);
      offset_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* LimitExpr::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .Mysqlx.Expr.Expr row_count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_row_count(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .Mysqlx.Expr.Expr offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_offset(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LimitExpr::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.LimitExpr)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Expr.Expr row_count = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::row_count(this), target, stream);
  }

  // optional .Mysqlx.Expr.Expr offset = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::offset(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.LimitExpr)
  return target;
}

size_t LimitExpr::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.LimitExpr)
  size_t total_size = 0;

  // required .Mysqlx.Expr.Expr row_count = 1;
  if (_internal_has_row_count()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *row_count_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .Mysqlx.Expr.Expr offset = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *offset_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LimitExpr::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LimitExpr*>(
      &from));
}

void LimitExpr::MergeFrom(const LimitExpr& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.LimitExpr)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_row_count()->::Mysqlx::Expr::Expr::MergeFrom(from._internal_row_count());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_offset()->::Mysqlx::Expr::Expr::MergeFrom(from._internal_offset());
    }
  }
}

void LimitExpr::CopyFrom(const LimitExpr& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.LimitExpr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LimitExpr::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (_internal_has_row_count()) {
    if (!row_count_->IsInitialized()) return false;
  }
  if (_internal_has_offset()) {
    if (!offset_->IsInitialized()) return false;
  }
  return true;
}

void LimitExpr::InternalSwap(LimitExpr* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(row_count_, other->row_count_);
  swap(offset_, other->offset_);
}

std::string LimitExpr::GetTypeName() const {
  return "Mysqlx.Crud.LimitExpr";
}


// ===================================================================

void Order::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_Order_default_instance_._instance.get_mutable()->expr_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
}
class Order::_Internal {
 public:
  using HasBits = decltype(std::declval<Order>()._has_bits_);
  static const ::Mysqlx::Expr::Expr& expr(const Order* msg);
  static void set_has_expr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::Mysqlx::Expr::Expr&
Order::_Internal::expr(const Order* msg) {
  return *msg->expr_;
}
void Order::clear_expr() {
  if (expr_ != nullptr) expr_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
Order::Order()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Order)
}
Order::Order(const Order& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_expr()) {
    expr_ = new ::Mysqlx::Expr::Expr(*from.expr_);
  } else {
    expr_ = nullptr;
  }
  direction_ = from.direction_;
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Order)
}

void Order::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Order_mysqlx_5fcrud_2eproto.base);
  expr_ = nullptr;
  direction_ = 1;
}

Order::~Order() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Order)
  SharedDtor();
}

void Order::SharedDtor() {
  if (this != internal_default_instance()) delete expr_;
}

void Order::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Order& Order::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Order_mysqlx_5fcrud_2eproto.base);
  return *internal_default_instance();
}


void Order::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Order)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(expr_ != nullptr);
      expr_->Clear();
    }
    direction_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Order::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .Mysqlx.Expr.Expr expr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_expr(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Mysqlx::Crud::Order_Direction_IsValid(val))) {
            _internal_set_direction(static_cast<::Mysqlx::Crud::Order_Direction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Order::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Order)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Expr.Expr expr = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::expr(this), target, stream);
  }

  // optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_direction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Order)
  return target;
}

size_t Order::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Order)
  size_t total_size = 0;

  // required .Mysqlx.Expr.Expr expr = 1;
  if (_internal_has_expr()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *expr_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .Mysqlx.Crud.Order.Direction direction = 2 [default = ASC];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_direction());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Order::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Order*>(
      &from));
}

void Order::MergeFrom(const Order& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Order)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_expr()->::Mysqlx::Expr::Expr::MergeFrom(from._internal_expr());
    }
    if (cached_has_bits & 0x00000002u) {
      direction_ = from.direction_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Order::CopyFrom(const Order& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Order)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Order::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (_internal_has_expr()) {
    if (!expr_->IsInitialized()) return false;
  }
  return true;
}

void Order::InternalSwap(Order* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(expr_, other->expr_);
  swap(direction_, other->direction_);
}

std::string Order::GetTypeName() const {
  return "Mysqlx.Crud.Order";
}


// ===================================================================

void UpdateOperation::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_UpdateOperation_default_instance_._instance.get_mutable()->source_ = const_cast< ::Mysqlx::Expr::ColumnIdentifier*>(
      ::Mysqlx::Expr::ColumnIdentifier::internal_default_instance());
  ::Mysqlx::Crud::_UpdateOperation_default_instance_._instance.get_mutable()->value_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
}
class UpdateOperation::_Internal {
 public:
  using HasBits = decltype(std::declval<UpdateOperation>()._has_bits_);
  static const ::Mysqlx::Expr::ColumnIdentifier& source(const UpdateOperation* msg);
  static void set_has_source(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_operation(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::Mysqlx::Expr::Expr& value(const UpdateOperation* msg);
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::Mysqlx::Expr::ColumnIdentifier&
UpdateOperation::_Internal::source(const UpdateOperation* msg) {
  return *msg->source_;
}
const ::Mysqlx::Expr::Expr&
UpdateOperation::_Internal::value(const UpdateOperation* msg) {
  return *msg->value_;
}
void UpdateOperation::clear_source() {
  if (source_ != nullptr) source_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void UpdateOperation::clear_value() {
  if (value_ != nullptr) value_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
UpdateOperation::UpdateOperation()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.UpdateOperation)
}
UpdateOperation::UpdateOperation(const UpdateOperation& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_source()) {
    source_ = new ::Mysqlx::Expr::ColumnIdentifier(*from.source_);
  } else {
    source_ = nullptr;
  }
  if (from._internal_has_value()) {
    value_ = new ::Mysqlx::Expr::Expr(*from.value_);
  } else {
    value_ = nullptr;
  }
  operation_ = from.operation_;
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.UpdateOperation)
}

void UpdateOperation::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UpdateOperation_mysqlx_5fcrud_2eproto.base);
  ::memset(&source_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&value_) -
      reinterpret_cast<char*>(&source_)) + sizeof(value_));
  operation_ = 1;
}

UpdateOperation::~UpdateOperation() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.UpdateOperation)
  SharedDtor();
}

void UpdateOperation::SharedDtor() {
  if (this != internal_default_instance()) delete source_;
  if (this != internal_default_instance()) delete value_;
}

void UpdateOperation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UpdateOperation& UpdateOperation::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UpdateOperation_mysqlx_5fcrud_2eproto.base);
  return *internal_default_instance();
}


void UpdateOperation::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.UpdateOperation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(source_ != nullptr);
      source_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(value_ != nullptr);
      value_->Clear();
    }
    operation_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* UpdateOperation::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .Mysqlx.Expr.ColumnIdentifier source = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_source(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Mysqlx::Crud::UpdateOperation_UpdateType_IsValid(val))) {
            _internal_set_operation(static_cast<::Mysqlx::Crud::UpdateOperation_UpdateType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .Mysqlx.Expr.Expr value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* UpdateOperation::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.UpdateOperation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Expr.ColumnIdentifier source = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::source(this), target, stream);
  }

  // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_operation(), target);
  }

  // optional .Mysqlx.Expr.Expr value = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::value(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.UpdateOperation)
  return target;
}

size_t UpdateOperation::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Mysqlx.Crud.UpdateOperation)
  size_t total_size = 0;

  if (_internal_has_source()) {
    // required .Mysqlx.Expr.ColumnIdentifier source = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *source_);
  }

  if (_internal_has_operation()) {
    // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_operation());
  }

  return total_size;
}
size_t UpdateOperation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.UpdateOperation)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000005) ^ 0x00000005) == 0) {  // All required fields are present.
    // required .Mysqlx.Expr.ColumnIdentifier source = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *source_);

    // required .Mysqlx.Crud.UpdateOperation.UpdateType operation = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_operation());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .Mysqlx.Expr.Expr value = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *value_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UpdateOperation::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const UpdateOperation*>(
      &from));
}

void UpdateOperation::MergeFrom(const UpdateOperation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.UpdateOperation)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_source()->::Mysqlx::Expr::ColumnIdentifier::MergeFrom(from._internal_source());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_value()->::Mysqlx::Expr::Expr::MergeFrom(from._internal_value());
    }
    if (cached_has_bits & 0x00000004u) {
      operation_ = from.operation_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UpdateOperation::CopyFrom(const UpdateOperation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.UpdateOperation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateOperation::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000005) != 0x00000005) return false;
  if (_internal_has_source()) {
    if (!source_->IsInitialized()) return false;
  }
  if (_internal_has_value()) {
    if (!value_->IsInitialized()) return false;
  }
  return true;
}

void UpdateOperation::InternalSwap(UpdateOperation* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(source_, other->source_);
  swap(value_, other->value_);
  swap(operation_, other->operation_);
}

std::string UpdateOperation::GetTypeName() const {
  return "Mysqlx.Crud.UpdateOperation";
}


// ===================================================================

void Find::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_Find_default_instance_._instance.get_mutable()->collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
  ::Mysqlx::Crud::_Find_default_instance_._instance.get_mutable()->criteria_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
  ::Mysqlx::Crud::_Find_default_instance_._instance.get_mutable()->grouping_criteria_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
  ::Mysqlx::Crud::_Find_default_instance_._instance.get_mutable()->limit_ = const_cast< ::Mysqlx::Crud::Limit*>(
      ::Mysqlx::Crud::Limit::internal_default_instance());
  ::Mysqlx::Crud::_Find_default_instance_._instance.get_mutable()->limit_expr_ = const_cast< ::Mysqlx::Crud::LimitExpr*>(
      ::Mysqlx::Crud::LimitExpr::internal_default_instance());
}
class Find::_Internal {
 public:
  using HasBits = decltype(std::declval<Find>()._has_bits_);
  static const ::Mysqlx::Crud::Collection& collection(const Find* msg);
  static void set_has_collection(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_data_model(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::Mysqlx::Expr::Expr& criteria(const Find* msg);
  static void set_has_criteria(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::Mysqlx::Expr::Expr& grouping_criteria(const Find* msg);
  static void set_has_grouping_criteria(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_locking(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_locking_options(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::Mysqlx::Crud::Limit& limit(const Find* msg);
  static void set_has_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::Mysqlx::Crud::LimitExpr& limit_expr(const Find* msg);
  static void set_has_limit_expr(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::Mysqlx::Crud::Collection&
Find::_Internal::collection(const Find* msg) {
  return *msg->collection_;
}
const ::Mysqlx::Expr::Expr&
Find::_Internal::criteria(const Find* msg) {
  return *msg->criteria_;
}
const ::Mysqlx::Expr::Expr&
Find::_Internal::grouping_criteria(const Find* msg) {
  return *msg->grouping_criteria_;
}
const ::Mysqlx::Crud::Limit&
Find::_Internal::limit(const Find* msg) {
  return *msg->limit_;
}
const ::Mysqlx::Crud::LimitExpr&
Find::_Internal::limit_expr(const Find* msg) {
  return *msg->limit_expr_;
}
void Find::clear_criteria() {
  if (criteria_ != nullptr) criteria_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void Find::clear_args() {
  args_.Clear();
}
void Find::clear_grouping() {
  grouping_.Clear();
}
void Find::clear_grouping_criteria() {
  if (grouping_criteria_ != nullptr) grouping_criteria_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
Find::Find()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Find)
}
Find::Find(const Find& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      projection_(from.projection_),
      order_(from.order_),
      grouping_(from.grouping_),
      args_(from.args_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_collection()) {
    collection_ = new ::Mysqlx::Crud::Collection(*from.collection_);
  } else {
    collection_ = nullptr;
  }
  if (from._internal_has_criteria()) {
    criteria_ = new ::Mysqlx::Expr::Expr(*from.criteria_);
  } else {
    criteria_ = nullptr;
  }
  if (from._internal_has_limit()) {
    limit_ = new ::Mysqlx::Crud::Limit(*from.limit_);
  } else {
    limit_ = nullptr;
  }
  if (from._internal_has_grouping_criteria()) {
    grouping_criteria_ = new ::Mysqlx::Expr::Expr(*from.grouping_criteria_);
  } else {
    grouping_criteria_ = nullptr;
  }
  if (from._internal_has_limit_expr()) {
    limit_expr_ = new ::Mysqlx::Crud::LimitExpr(*from.limit_expr_);
  } else {
    limit_expr_ = nullptr;
  }
  ::memcpy(&locking_options_, &from.locking_options_,
    static_cast<size_t>(reinterpret_cast<char*>(&locking_) -
    reinterpret_cast<char*>(&locking_options_)) + sizeof(locking_));
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Find)
}

void Find::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Find_mysqlx_5fcrud_2eproto.base);
  ::memset(&collection_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&limit_expr_) -
      reinterpret_cast<char*>(&collection_)) + sizeof(limit_expr_));
  locking_options_ = 1;
  data_model_ = 1;
  locking_ = 1;
}

Find::~Find() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Find)
  SharedDtor();
}

void Find::SharedDtor() {
  if (this != internal_default_instance()) delete collection_;
  if (this != internal_default_instance()) delete criteria_;
  if (this != internal_default_instance()) delete limit_;
  if (this != internal_default_instance()) delete grouping_criteria_;
  if (this != internal_default_instance()) delete limit_expr_;
}

void Find::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Find& Find::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Find_mysqlx_5fcrud_2eproto.base);
  return *internal_default_instance();
}


void Find::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Find)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  projection_.Clear();
  order_.Clear();
  grouping_.Clear();
  args_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(collection_ != nullptr);
      collection_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(criteria_ != nullptr);
      criteria_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(limit_ != nullptr);
      limit_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(grouping_criteria_ != nullptr);
      grouping_criteria_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(limit_expr_ != nullptr);
      limit_expr_->Clear();
    }
    locking_options_ = 1;
    data_model_ = 1;
    locking_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Find::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .Mysqlx.Crud.Collection collection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_collection(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .Mysqlx.Crud.DataModel data_model = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Mysqlx::Crud::DataModel_IsValid(val))) {
            _internal_set_data_model(static_cast<::Mysqlx::Crud::DataModel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated .Mysqlx.Crud.Projection projection = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_projection(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .Mysqlx.Expr.Expr criteria = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_criteria(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .Mysqlx.Crud.Limit limit = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_limit(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .Mysqlx.Crud.Order order = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_order(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .Mysqlx.Expr.Expr grouping = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_grouping(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .Mysqlx.Expr.Expr grouping_criteria = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_grouping_criteria(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .Mysqlx.Datatypes.Scalar args = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_args(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .Mysqlx.Crud.Find.RowLock locking = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Mysqlx::Crud::Find_RowLock_IsValid(val))) {
            _internal_set_locking(static_cast<::Mysqlx::Crud::Find_RowLock>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(12, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .Mysqlx.Crud.Find.RowLockOptions locking_options = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Mysqlx::Crud::Find_RowLockOptions_IsValid(val))) {
            _internal_set_locking_options(static_cast<::Mysqlx::Crud::Find_RowLockOptions>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(13, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .Mysqlx.Crud.LimitExpr limit_expr = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_limit_expr(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Find::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Find)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Crud.Collection collection = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::collection(this), target, stream);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_data_model(), target);
  }

  // repeated .Mysqlx.Crud.Projection projection = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_projection_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_projection(i), target, stream);
  }

  // optional .Mysqlx.Expr.Expr criteria = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::criteria(this), target, stream);
  }

  // optional .Mysqlx.Crud.Limit limit = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::limit(this), target, stream);
  }

  // repeated .Mysqlx.Crud.Order order = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_order_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, this->_internal_order(i), target, stream);
  }

  // repeated .Mysqlx.Expr.Expr grouping = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_grouping_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, this->_internal_grouping(i), target, stream);
  }

  // optional .Mysqlx.Expr.Expr grouping_criteria = 9;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::grouping_criteria(this), target, stream);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 11;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_args_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, this->_internal_args(i), target, stream);
  }

  // optional .Mysqlx.Crud.Find.RowLock locking = 12;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      12, this->_internal_locking(), target);
  }

  // optional .Mysqlx.Crud.Find.RowLockOptions locking_options = 13;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      13, this->_internal_locking_options(), target);
  }

  // optional .Mysqlx.Crud.LimitExpr limit_expr = 14;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        14, _Internal::limit_expr(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Find)
  return target;
}

size_t Find::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Find)
  size_t total_size = 0;

  // required .Mysqlx.Crud.Collection collection = 2;
  if (_internal_has_collection()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *collection_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Mysqlx.Crud.Projection projection = 4;
  total_size += 1UL * this->_internal_projection_size();
  for (const auto& msg : this->projection_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Mysqlx.Crud.Order order = 7;
  total_size += 1UL * this->_internal_order_size();
  for (const auto& msg : this->order_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Mysqlx.Expr.Expr grouping = 8;
  total_size += 1UL * this->_internal_grouping_size();
  for (const auto& msg : this->grouping_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 11;
  total_size += 1UL * this->_internal_args_size();
  for (const auto& msg : this->args_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000feu) {
    // optional .Mysqlx.Expr.Expr criteria = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *criteria_);
    }

    // optional .Mysqlx.Crud.Limit limit = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *limit_);
    }

    // optional .Mysqlx.Expr.Expr grouping_criteria = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *grouping_criteria_);
    }

    // optional .Mysqlx.Crud.LimitExpr limit_expr = 14;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *limit_expr_);
    }

    // optional .Mysqlx.Crud.Find.RowLockOptions locking_options = 13;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_locking_options());
    }

    // optional .Mysqlx.Crud.DataModel data_model = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_data_model());
    }

    // optional .Mysqlx.Crud.Find.RowLock locking = 12;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_locking());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Find::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Find*>(
      &from));
}

void Find::MergeFrom(const Find& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Find)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  projection_.MergeFrom(from.projection_);
  order_.MergeFrom(from.order_);
  grouping_.MergeFrom(from.grouping_);
  args_.MergeFrom(from.args_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from._internal_collection());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_criteria()->::Mysqlx::Expr::Expr::MergeFrom(from._internal_criteria());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_limit()->::Mysqlx::Crud::Limit::MergeFrom(from._internal_limit());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_grouping_criteria()->::Mysqlx::Expr::Expr::MergeFrom(from._internal_grouping_criteria());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_limit_expr()->::Mysqlx::Crud::LimitExpr::MergeFrom(from._internal_limit_expr());
    }
    if (cached_has_bits & 0x00000020u) {
      locking_options_ = from.locking_options_;
    }
    if (cached_has_bits & 0x00000040u) {
      data_model_ = from.data_model_;
    }
    if (cached_has_bits & 0x00000080u) {
      locking_ = from.locking_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Find::CopyFrom(const Find& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Find)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Find::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(projection_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(order_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(grouping_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(args_)) return false;
  if (_internal_has_collection()) {
    if (!collection_->IsInitialized()) return false;
  }
  if (_internal_has_criteria()) {
    if (!criteria_->IsInitialized()) return false;
  }
  if (_internal_has_limit()) {
    if (!limit_->IsInitialized()) return false;
  }
  if (_internal_has_grouping_criteria()) {
    if (!grouping_criteria_->IsInitialized()) return false;
  }
  if (_internal_has_limit_expr()) {
    if (!limit_expr_->IsInitialized()) return false;
  }
  return true;
}

void Find::InternalSwap(Find* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  projection_.InternalSwap(&other->projection_);
  order_.InternalSwap(&other->order_);
  grouping_.InternalSwap(&other->grouping_);
  args_.InternalSwap(&other->args_);
  swap(collection_, other->collection_);
  swap(criteria_, other->criteria_);
  swap(limit_, other->limit_);
  swap(grouping_criteria_, other->grouping_criteria_);
  swap(limit_expr_, other->limit_expr_);
  swap(locking_options_, other->locking_options_);
  swap(data_model_, other->data_model_);
  swap(locking_, other->locking_);
}

std::string Find::GetTypeName() const {
  return "Mysqlx.Crud.Find";
}


// ===================================================================

void Insert_TypedRow::InitAsDefaultInstance() {
}
class Insert_TypedRow::_Internal {
 public:
  using HasBits = decltype(std::declval<Insert_TypedRow>()._has_bits_);
};

void Insert_TypedRow::clear_field() {
  field_.Clear();
}
Insert_TypedRow::Insert_TypedRow()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Insert.TypedRow)
}
Insert_TypedRow::Insert_TypedRow(const Insert_TypedRow& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      field_(from.field_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Insert.TypedRow)
}

void Insert_TypedRow::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Insert_TypedRow_mysqlx_5fcrud_2eproto.base);
}

Insert_TypedRow::~Insert_TypedRow() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Insert.TypedRow)
  SharedDtor();
}

void Insert_TypedRow::SharedDtor() {
}

void Insert_TypedRow::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Insert_TypedRow& Insert_TypedRow::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Insert_TypedRow_mysqlx_5fcrud_2eproto.base);
  return *internal_default_instance();
}


void Insert_TypedRow::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Insert.TypedRow)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  field_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Insert_TypedRow::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .Mysqlx.Expr.Expr field = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_field(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Insert_TypedRow::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Insert.TypedRow)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Mysqlx.Expr.Expr field = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_field_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_field(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Insert.TypedRow)
  return target;
}

size_t Insert_TypedRow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Insert.TypedRow)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Mysqlx.Expr.Expr field = 1;
  total_size += 1UL * this->_internal_field_size();
  for (const auto& msg : this->field_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Insert_TypedRow::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Insert_TypedRow*>(
      &from));
}

void Insert_TypedRow::MergeFrom(const Insert_TypedRow& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Insert.TypedRow)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  field_.MergeFrom(from.field_);
}

void Insert_TypedRow::CopyFrom(const Insert_TypedRow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Insert.TypedRow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Insert_TypedRow::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(field_)) return false;
  return true;
}

void Insert_TypedRow::InternalSwap(Insert_TypedRow* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  field_.InternalSwap(&other->field_);
}

std::string Insert_TypedRow::GetTypeName() const {
  return "Mysqlx.Crud.Insert.TypedRow";
}


// ===================================================================

void Insert::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_Insert_default_instance_._instance.get_mutable()->collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
}
class Insert::_Internal {
 public:
  using HasBits = decltype(std::declval<Insert>()._has_bits_);
  static const ::Mysqlx::Crud::Collection& collection(const Insert* msg);
  static void set_has_collection(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_data_model(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_upsert(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::Mysqlx::Crud::Collection&
Insert::_Internal::collection(const Insert* msg) {
  return *msg->collection_;
}
void Insert::clear_args() {
  args_.Clear();
}
Insert::Insert()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Insert)
}
Insert::Insert(const Insert& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      projection_(from.projection_),
      row_(from.row_),
      args_(from.args_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_collection()) {
    collection_ = new ::Mysqlx::Crud::Collection(*from.collection_);
  } else {
    collection_ = nullptr;
  }
  ::memcpy(&upsert_, &from.upsert_,
    static_cast<size_t>(reinterpret_cast<char*>(&data_model_) -
    reinterpret_cast<char*>(&upsert_)) + sizeof(data_model_));
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Insert)
}

void Insert::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Insert_mysqlx_5fcrud_2eproto.base);
  ::memset(&collection_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&upsert_) -
      reinterpret_cast<char*>(&collection_)) + sizeof(upsert_));
  data_model_ = 1;
}

Insert::~Insert() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Insert)
  SharedDtor();
}

void Insert::SharedDtor() {
  if (this != internal_default_instance()) delete collection_;
}

void Insert::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Insert& Insert::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Insert_mysqlx_5fcrud_2eproto.base);
  return *internal_default_instance();
}


void Insert::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Insert)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  projection_.Clear();
  row_.Clear();
  args_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(collection_ != nullptr);
    collection_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    upsert_ = false;
    data_model_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Insert::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .Mysqlx.Crud.Collection collection = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_collection(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .Mysqlx.Crud.DataModel data_model = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Mysqlx::Crud::DataModel_IsValid(val))) {
            _internal_set_data_model(static_cast<::Mysqlx::Crud::DataModel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated .Mysqlx.Crud.Column projection = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_projection(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_row(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .Mysqlx.Datatypes.Scalar args = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_args(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else goto handle_unusual;
        continue;
      // optional bool upsert = 6 [default = false];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_upsert(&has_bits);
          upsert_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Insert::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Insert)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Crud.Collection collection = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::collection(this), target, stream);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_data_model(), target);
  }

  // repeated .Mysqlx.Crud.Column projection = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_projection_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_projection(i), target, stream);
  }

  // repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_row_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_row(i), target, stream);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_args_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_args(i), target, stream);
  }

  // optional bool upsert = 6 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_upsert(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Insert)
  return target;
}

size_t Insert::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Insert)
  size_t total_size = 0;

  // required .Mysqlx.Crud.Collection collection = 1;
  if (_internal_has_collection()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *collection_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Mysqlx.Crud.Column projection = 3;
  total_size += 1UL * this->_internal_projection_size();
  for (const auto& msg : this->projection_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Mysqlx.Crud.Insert.TypedRow row = 4;
  total_size += 1UL * this->_internal_row_size();
  for (const auto& msg : this->row_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 5;
  total_size += 1UL * this->_internal_args_size();
  for (const auto& msg : this->args_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional bool upsert = 6 [default = false];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional .Mysqlx.Crud.DataModel data_model = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_data_model());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Insert::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Insert*>(
      &from));
}

void Insert::MergeFrom(const Insert& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Insert)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  projection_.MergeFrom(from.projection_);
  row_.MergeFrom(from.row_);
  args_.MergeFrom(from.args_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from._internal_collection());
    }
    if (cached_has_bits & 0x00000002u) {
      upsert_ = from.upsert_;
    }
    if (cached_has_bits & 0x00000004u) {
      data_model_ = from.data_model_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Insert::CopyFrom(const Insert& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Insert)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Insert::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(projection_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(row_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(args_)) return false;
  if (_internal_has_collection()) {
    if (!collection_->IsInitialized()) return false;
  }
  return true;
}

void Insert::InternalSwap(Insert* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  projection_.InternalSwap(&other->projection_);
  row_.InternalSwap(&other->row_);
  args_.InternalSwap(&other->args_);
  swap(collection_, other->collection_);
  swap(upsert_, other->upsert_);
  swap(data_model_, other->data_model_);
}

std::string Insert::GetTypeName() const {
  return "Mysqlx.Crud.Insert";
}


// ===================================================================

void Update::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_Update_default_instance_._instance.get_mutable()->collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
  ::Mysqlx::Crud::_Update_default_instance_._instance.get_mutable()->criteria_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
  ::Mysqlx::Crud::_Update_default_instance_._instance.get_mutable()->limit_ = const_cast< ::Mysqlx::Crud::Limit*>(
      ::Mysqlx::Crud::Limit::internal_default_instance());
  ::Mysqlx::Crud::_Update_default_instance_._instance.get_mutable()->limit_expr_ = const_cast< ::Mysqlx::Crud::LimitExpr*>(
      ::Mysqlx::Crud::LimitExpr::internal_default_instance());
}
class Update::_Internal {
 public:
  using HasBits = decltype(std::declval<Update>()._has_bits_);
  static const ::Mysqlx::Crud::Collection& collection(const Update* msg);
  static void set_has_collection(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_data_model(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::Mysqlx::Expr::Expr& criteria(const Update* msg);
  static void set_has_criteria(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::Mysqlx::Crud::Limit& limit(const Update* msg);
  static void set_has_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::Mysqlx::Crud::LimitExpr& limit_expr(const Update* msg);
  static void set_has_limit_expr(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::Mysqlx::Crud::Collection&
Update::_Internal::collection(const Update* msg) {
  return *msg->collection_;
}
const ::Mysqlx::Expr::Expr&
Update::_Internal::criteria(const Update* msg) {
  return *msg->criteria_;
}
const ::Mysqlx::Crud::Limit&
Update::_Internal::limit(const Update* msg) {
  return *msg->limit_;
}
const ::Mysqlx::Crud::LimitExpr&
Update::_Internal::limit_expr(const Update* msg) {
  return *msg->limit_expr_;
}
void Update::clear_criteria() {
  if (criteria_ != nullptr) criteria_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void Update::clear_args() {
  args_.Clear();
}
Update::Update()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Update)
}
Update::Update(const Update& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      order_(from.order_),
      operation_(from.operation_),
      args_(from.args_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_collection()) {
    collection_ = new ::Mysqlx::Crud::Collection(*from.collection_);
  } else {
    collection_ = nullptr;
  }
  if (from._internal_has_criteria()) {
    criteria_ = new ::Mysqlx::Expr::Expr(*from.criteria_);
  } else {
    criteria_ = nullptr;
  }
  if (from._internal_has_limit()) {
    limit_ = new ::Mysqlx::Crud::Limit(*from.limit_);
  } else {
    limit_ = nullptr;
  }
  if (from._internal_has_limit_expr()) {
    limit_expr_ = new ::Mysqlx::Crud::LimitExpr(*from.limit_expr_);
  } else {
    limit_expr_ = nullptr;
  }
  data_model_ = from.data_model_;
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Update)
}

void Update::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Update_mysqlx_5fcrud_2eproto.base);
  ::memset(&collection_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&limit_expr_) -
      reinterpret_cast<char*>(&collection_)) + sizeof(limit_expr_));
  data_model_ = 1;
}

Update::~Update() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Update)
  SharedDtor();
}

void Update::SharedDtor() {
  if (this != internal_default_instance()) delete collection_;
  if (this != internal_default_instance()) delete criteria_;
  if (this != internal_default_instance()) delete limit_;
  if (this != internal_default_instance()) delete limit_expr_;
}

void Update::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Update& Update::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Update_mysqlx_5fcrud_2eproto.base);
  return *internal_default_instance();
}


void Update::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Update)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  order_.Clear();
  operation_.Clear();
  args_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(collection_ != nullptr);
      collection_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(criteria_ != nullptr);
      criteria_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(limit_ != nullptr);
      limit_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(limit_expr_ != nullptr);
      limit_expr_->Clear();
    }
    data_model_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Update::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .Mysqlx.Crud.Collection collection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_collection(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .Mysqlx.Crud.DataModel data_model = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Mysqlx::Crud::DataModel_IsValid(val))) {
            _internal_set_data_model(static_cast<::Mysqlx::Crud::DataModel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .Mysqlx.Expr.Expr criteria = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_criteria(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .Mysqlx.Crud.Limit limit = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_limit(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .Mysqlx.Crud.Order order = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_order(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .Mysqlx.Crud.UpdateOperation operation = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_operation(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .Mysqlx.Datatypes.Scalar args = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_args(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .Mysqlx.Crud.LimitExpr limit_expr = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_limit_expr(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Update::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Update)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Crud.Collection collection = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::collection(this), target, stream);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_data_model(), target);
  }

  // optional .Mysqlx.Expr.Expr criteria = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::criteria(this), target, stream);
  }

  // optional .Mysqlx.Crud.Limit limit = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::limit(this), target, stream);
  }

  // repeated .Mysqlx.Crud.Order order = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_order_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_order(i), target, stream);
  }

  // repeated .Mysqlx.Crud.UpdateOperation operation = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_operation_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, this->_internal_operation(i), target, stream);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_args_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, this->_internal_args(i), target, stream);
  }

  // optional .Mysqlx.Crud.LimitExpr limit_expr = 9;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::limit_expr(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Update)
  return target;
}

size_t Update::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Update)
  size_t total_size = 0;

  // required .Mysqlx.Crud.Collection collection = 2;
  if (_internal_has_collection()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *collection_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Mysqlx.Crud.Order order = 6;
  total_size += 1UL * this->_internal_order_size();
  for (const auto& msg : this->order_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Mysqlx.Crud.UpdateOperation operation = 7;
  total_size += 1UL * this->_internal_operation_size();
  for (const auto& msg : this->operation_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 8;
  total_size += 1UL * this->_internal_args_size();
  for (const auto& msg : this->args_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001eu) {
    // optional .Mysqlx.Expr.Expr criteria = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *criteria_);
    }

    // optional .Mysqlx.Crud.Limit limit = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *limit_);
    }

    // optional .Mysqlx.Crud.LimitExpr limit_expr = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *limit_expr_);
    }

    // optional .Mysqlx.Crud.DataModel data_model = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_data_model());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Update::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Update*>(
      &from));
}

void Update::MergeFrom(const Update& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Update)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  order_.MergeFrom(from.order_);
  operation_.MergeFrom(from.operation_);
  args_.MergeFrom(from.args_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from._internal_collection());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_criteria()->::Mysqlx::Expr::Expr::MergeFrom(from._internal_criteria());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_limit()->::Mysqlx::Crud::Limit::MergeFrom(from._internal_limit());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_limit_expr()->::Mysqlx::Crud::LimitExpr::MergeFrom(from._internal_limit_expr());
    }
    if (cached_has_bits & 0x00000010u) {
      data_model_ = from.data_model_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Update::CopyFrom(const Update& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Update)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Update::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(order_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(operation_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(args_)) return false;
  if (_internal_has_collection()) {
    if (!collection_->IsInitialized()) return false;
  }
  if (_internal_has_criteria()) {
    if (!criteria_->IsInitialized()) return false;
  }
  if (_internal_has_limit()) {
    if (!limit_->IsInitialized()) return false;
  }
  if (_internal_has_limit_expr()) {
    if (!limit_expr_->IsInitialized()) return false;
  }
  return true;
}

void Update::InternalSwap(Update* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  order_.InternalSwap(&other->order_);
  operation_.InternalSwap(&other->operation_);
  args_.InternalSwap(&other->args_);
  swap(collection_, other->collection_);
  swap(criteria_, other->criteria_);
  swap(limit_, other->limit_);
  swap(limit_expr_, other->limit_expr_);
  swap(data_model_, other->data_model_);
}

std::string Update::GetTypeName() const {
  return "Mysqlx.Crud.Update";
}


// ===================================================================

void Delete::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_Delete_default_instance_._instance.get_mutable()->collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
  ::Mysqlx::Crud::_Delete_default_instance_._instance.get_mutable()->criteria_ = const_cast< ::Mysqlx::Expr::Expr*>(
      ::Mysqlx::Expr::Expr::internal_default_instance());
  ::Mysqlx::Crud::_Delete_default_instance_._instance.get_mutable()->limit_ = const_cast< ::Mysqlx::Crud::Limit*>(
      ::Mysqlx::Crud::Limit::internal_default_instance());
  ::Mysqlx::Crud::_Delete_default_instance_._instance.get_mutable()->limit_expr_ = const_cast< ::Mysqlx::Crud::LimitExpr*>(
      ::Mysqlx::Crud::LimitExpr::internal_default_instance());
}
class Delete::_Internal {
 public:
  using HasBits = decltype(std::declval<Delete>()._has_bits_);
  static const ::Mysqlx::Crud::Collection& collection(const Delete* msg);
  static void set_has_collection(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_data_model(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::Mysqlx::Expr::Expr& criteria(const Delete* msg);
  static void set_has_criteria(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::Mysqlx::Crud::Limit& limit(const Delete* msg);
  static void set_has_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::Mysqlx::Crud::LimitExpr& limit_expr(const Delete* msg);
  static void set_has_limit_expr(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::Mysqlx::Crud::Collection&
Delete::_Internal::collection(const Delete* msg) {
  return *msg->collection_;
}
const ::Mysqlx::Expr::Expr&
Delete::_Internal::criteria(const Delete* msg) {
  return *msg->criteria_;
}
const ::Mysqlx::Crud::Limit&
Delete::_Internal::limit(const Delete* msg) {
  return *msg->limit_;
}
const ::Mysqlx::Crud::LimitExpr&
Delete::_Internal::limit_expr(const Delete* msg) {
  return *msg->limit_expr_;
}
void Delete::clear_criteria() {
  if (criteria_ != nullptr) criteria_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void Delete::clear_args() {
  args_.Clear();
}
Delete::Delete()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.Delete)
}
Delete::Delete(const Delete& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      order_(from.order_),
      args_(from.args_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_collection()) {
    collection_ = new ::Mysqlx::Crud::Collection(*from.collection_);
  } else {
    collection_ = nullptr;
  }
  if (from._internal_has_criteria()) {
    criteria_ = new ::Mysqlx::Expr::Expr(*from.criteria_);
  } else {
    criteria_ = nullptr;
  }
  if (from._internal_has_limit()) {
    limit_ = new ::Mysqlx::Crud::Limit(*from.limit_);
  } else {
    limit_ = nullptr;
  }
  if (from._internal_has_limit_expr()) {
    limit_expr_ = new ::Mysqlx::Crud::LimitExpr(*from.limit_expr_);
  } else {
    limit_expr_ = nullptr;
  }
  data_model_ = from.data_model_;
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.Delete)
}

void Delete::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Delete_mysqlx_5fcrud_2eproto.base);
  ::memset(&collection_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&limit_expr_) -
      reinterpret_cast<char*>(&collection_)) + sizeof(limit_expr_));
  data_model_ = 1;
}

Delete::~Delete() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.Delete)
  SharedDtor();
}

void Delete::SharedDtor() {
  if (this != internal_default_instance()) delete collection_;
  if (this != internal_default_instance()) delete criteria_;
  if (this != internal_default_instance()) delete limit_;
  if (this != internal_default_instance()) delete limit_expr_;
}

void Delete::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Delete& Delete::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Delete_mysqlx_5fcrud_2eproto.base);
  return *internal_default_instance();
}


void Delete::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.Delete)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  order_.Clear();
  args_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(collection_ != nullptr);
      collection_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(criteria_ != nullptr);
      criteria_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(limit_ != nullptr);
      limit_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(limit_expr_ != nullptr);
      limit_expr_->Clear();
    }
    data_model_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Delete::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .Mysqlx.Crud.Collection collection = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_collection(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .Mysqlx.Crud.DataModel data_model = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Mysqlx::Crud::DataModel_IsValid(val))) {
            _internal_set_data_model(static_cast<::Mysqlx::Crud::DataModel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .Mysqlx.Expr.Expr criteria = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_criteria(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .Mysqlx.Crud.Limit limit = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_limit(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .Mysqlx.Crud.Order order = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_order(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .Mysqlx.Datatypes.Scalar args = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_args(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .Mysqlx.Crud.LimitExpr limit_expr = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_limit_expr(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Delete::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.Delete)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Crud.Collection collection = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::collection(this), target, stream);
  }

  // optional .Mysqlx.Crud.DataModel data_model = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_data_model(), target);
  }

  // optional .Mysqlx.Expr.Expr criteria = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::criteria(this), target, stream);
  }

  // optional .Mysqlx.Crud.Limit limit = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::limit(this), target, stream);
  }

  // repeated .Mysqlx.Crud.Order order = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_order_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_order(i), target, stream);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_args_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_args(i), target, stream);
  }

  // optional .Mysqlx.Crud.LimitExpr limit_expr = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::limit_expr(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.Delete)
  return target;
}

size_t Delete::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.Delete)
  size_t total_size = 0;

  // required .Mysqlx.Crud.Collection collection = 1;
  if (_internal_has_collection()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *collection_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Mysqlx.Crud.Order order = 5;
  total_size += 1UL * this->_internal_order_size();
  for (const auto& msg : this->order_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Mysqlx.Datatypes.Scalar args = 6;
  total_size += 1UL * this->_internal_args_size();
  for (const auto& msg : this->args_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001eu) {
    // optional .Mysqlx.Expr.Expr criteria = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *criteria_);
    }

    // optional .Mysqlx.Crud.Limit limit = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *limit_);
    }

    // optional .Mysqlx.Crud.LimitExpr limit_expr = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *limit_expr_);
    }

    // optional .Mysqlx.Crud.DataModel data_model = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_data_model());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Delete::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Delete*>(
      &from));
}

void Delete::MergeFrom(const Delete& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.Delete)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  order_.MergeFrom(from.order_);
  args_.MergeFrom(from.args_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from._internal_collection());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_criteria()->::Mysqlx::Expr::Expr::MergeFrom(from._internal_criteria());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_limit()->::Mysqlx::Crud::Limit::MergeFrom(from._internal_limit());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_limit_expr()->::Mysqlx::Crud::LimitExpr::MergeFrom(from._internal_limit_expr());
    }
    if (cached_has_bits & 0x00000010u) {
      data_model_ = from.data_model_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Delete::CopyFrom(const Delete& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.Delete)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Delete::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(order_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(args_)) return false;
  if (_internal_has_collection()) {
    if (!collection_->IsInitialized()) return false;
  }
  if (_internal_has_criteria()) {
    if (!criteria_->IsInitialized()) return false;
  }
  if (_internal_has_limit()) {
    if (!limit_->IsInitialized()) return false;
  }
  if (_internal_has_limit_expr()) {
    if (!limit_expr_->IsInitialized()) return false;
  }
  return true;
}

void Delete::InternalSwap(Delete* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  order_.InternalSwap(&other->order_);
  args_.InternalSwap(&other->args_);
  swap(collection_, other->collection_);
  swap(criteria_, other->criteria_);
  swap(limit_, other->limit_);
  swap(limit_expr_, other->limit_expr_);
  swap(data_model_, other->data_model_);
}

std::string Delete::GetTypeName() const {
  return "Mysqlx.Crud.Delete";
}


// ===================================================================

void CreateView::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_CreateView_default_instance_._instance.get_mutable()->collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
  ::Mysqlx::Crud::_CreateView_default_instance_._instance.get_mutable()->stmt_ = const_cast< ::Mysqlx::Crud::Find*>(
      ::Mysqlx::Crud::Find::internal_default_instance());
}
class CreateView::_Internal {
 public:
  using HasBits = decltype(std::declval<CreateView>()._has_bits_);
  static const ::Mysqlx::Crud::Collection& collection(const CreateView* msg);
  static void set_has_collection(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_definer(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_algorithm(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_security(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_check(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::Mysqlx::Crud::Find& stmt(const CreateView* msg);
  static void set_has_stmt(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_replace_existing(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::Mysqlx::Crud::Collection&
CreateView::_Internal::collection(const CreateView* msg) {
  return *msg->collection_;
}
const ::Mysqlx::Crud::Find&
CreateView::_Internal::stmt(const CreateView* msg) {
  return *msg->stmt_;
}
CreateView::CreateView()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.CreateView)
}
CreateView::CreateView(const CreateView& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      column_(from.column_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  definer_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_definer()) {
    definer_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.definer_);
  }
  if (from._internal_has_collection()) {
    collection_ = new ::Mysqlx::Crud::Collection(*from.collection_);
  } else {
    collection_ = nullptr;
  }
  if (from._internal_has_stmt()) {
    stmt_ = new ::Mysqlx::Crud::Find(*from.stmt_);
  } else {
    stmt_ = nullptr;
  }
  ::memcpy(&replace_existing_, &from.replace_existing_,
    static_cast<size_t>(reinterpret_cast<char*>(&security_) -
    reinterpret_cast<char*>(&replace_existing_)) + sizeof(security_));
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.CreateView)
}

void CreateView::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_CreateView_mysqlx_5fcrud_2eproto.base);
  definer_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&collection_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&replace_existing_) -
      reinterpret_cast<char*>(&collection_)) + sizeof(replace_existing_));
  check_ = 1;
  algorithm_ = 1;
  security_ = 2;
}

CreateView::~CreateView() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.CreateView)
  SharedDtor();
}

void CreateView::SharedDtor() {
  definer_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete collection_;
  if (this != internal_default_instance()) delete stmt_;
}

void CreateView::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CreateView& CreateView::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CreateView_mysqlx_5fcrud_2eproto.base);
  return *internal_default_instance();
}


void CreateView::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.CreateView)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  column_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      definer_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(collection_ != nullptr);
      collection_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(stmt_ != nullptr);
      stmt_->Clear();
    }
  }
  if (cached_has_bits & 0x00000078u) {
    replace_existing_ = false;
    check_ = 1;
    algorithm_ = 1;
    security_ = 2;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* CreateView::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .Mysqlx.Crud.Collection collection = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_collection(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string definer = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_definer();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .Mysqlx.Crud.ViewAlgorithm algorithm = 3 [default = UNDEFINED];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Mysqlx::Crud::ViewAlgorithm_IsValid(val))) {
            _internal_set_algorithm(static_cast<::Mysqlx::Crud::ViewAlgorithm>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .Mysqlx.Crud.ViewSqlSecurity security = 4 [default = DEFINER];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Mysqlx::Crud::ViewSqlSecurity_IsValid(val))) {
            _internal_set_security(static_cast<::Mysqlx::Crud::ViewSqlSecurity>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .Mysqlx.Crud.ViewCheckOption check = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Mysqlx::Crud::ViewCheckOption_IsValid(val))) {
            _internal_set_check(static_cast<::Mysqlx::Crud::ViewCheckOption>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated string column = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_column();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else goto handle_unusual;
        continue;
      // required .Mysqlx.Crud.Find stmt = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_stmt(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool replace_existing = 8 [default = false];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_replace_existing(&has_bits);
          replace_existing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CreateView::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.CreateView)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Crud.Collection collection = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::collection(this), target, stream);
  }

  // optional string definer = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_definer(), target);
  }

  // optional .Mysqlx.Crud.ViewAlgorithm algorithm = 3 [default = UNDEFINED];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_algorithm(), target);
  }

  // optional .Mysqlx.Crud.ViewSqlSecurity security = 4 [default = DEFINER];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_security(), target);
  }

  // optional .Mysqlx.Crud.ViewCheckOption check = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_check(), target);
  }

  // repeated string column = 6;
  for (int i = 0, n = this->_internal_column_size(); i < n; i++) {
    const auto& s = this->_internal_column(i);
    target = stream->WriteString(6, s, target);
  }

  // required .Mysqlx.Crud.Find stmt = 7;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::stmt(this), target, stream);
  }

  // optional bool replace_existing = 8 [default = false];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_replace_existing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.CreateView)
  return target;
}

size_t CreateView::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Mysqlx.Crud.CreateView)
  size_t total_size = 0;

  if (_internal_has_collection()) {
    // required .Mysqlx.Crud.Collection collection = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *collection_);
  }

  if (_internal_has_stmt()) {
    // required .Mysqlx.Crud.Find stmt = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *stmt_);
  }

  return total_size;
}
size_t CreateView::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.CreateView)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required .Mysqlx.Crud.Collection collection = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *collection_);

    // required .Mysqlx.Crud.Find stmt = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *stmt_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string column = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(column_.size());
  for (int i = 0, n = column_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      column_.Get(i));
  }

  // optional string definer = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_definer());
  }

  if (cached_has_bits & 0x00000078u) {
    // optional bool replace_existing = 8 [default = false];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional .Mysqlx.Crud.ViewCheckOption check = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_check());
    }

    // optional .Mysqlx.Crud.ViewAlgorithm algorithm = 3 [default = UNDEFINED];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_algorithm());
    }

    // optional .Mysqlx.Crud.ViewSqlSecurity security = 4 [default = DEFINER];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_security());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CreateView::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CreateView*>(
      &from));
}

void CreateView::MergeFrom(const CreateView& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.CreateView)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  column_.MergeFrom(from.column_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      definer_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.definer_);
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from._internal_collection());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_stmt()->::Mysqlx::Crud::Find::MergeFrom(from._internal_stmt());
    }
    if (cached_has_bits & 0x00000008u) {
      replace_existing_ = from.replace_existing_;
    }
    if (cached_has_bits & 0x00000010u) {
      check_ = from.check_;
    }
    if (cached_has_bits & 0x00000020u) {
      algorithm_ = from.algorithm_;
    }
    if (cached_has_bits & 0x00000040u) {
      security_ = from.security_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CreateView::CopyFrom(const CreateView& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.CreateView)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateView::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;
  if (_internal_has_collection()) {
    if (!collection_->IsInitialized()) return false;
  }
  if (_internal_has_stmt()) {
    if (!stmt_->IsInitialized()) return false;
  }
  return true;
}

void CreateView::InternalSwap(CreateView* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  column_.InternalSwap(&other->column_);
  definer_.Swap(&other->definer_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(collection_, other->collection_);
  swap(stmt_, other->stmt_);
  swap(replace_existing_, other->replace_existing_);
  swap(check_, other->check_);
  swap(algorithm_, other->algorithm_);
  swap(security_, other->security_);
}

std::string CreateView::GetTypeName() const {
  return "Mysqlx.Crud.CreateView";
}


// ===================================================================

void ModifyView::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_ModifyView_default_instance_._instance.get_mutable()->collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
  ::Mysqlx::Crud::_ModifyView_default_instance_._instance.get_mutable()->stmt_ = const_cast< ::Mysqlx::Crud::Find*>(
      ::Mysqlx::Crud::Find::internal_default_instance());
}
class ModifyView::_Internal {
 public:
  using HasBits = decltype(std::declval<ModifyView>()._has_bits_);
  static const ::Mysqlx::Crud::Collection& collection(const ModifyView* msg);
  static void set_has_collection(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_definer(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_algorithm(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_security(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_check(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::Mysqlx::Crud::Find& stmt(const ModifyView* msg);
  static void set_has_stmt(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::Mysqlx::Crud::Collection&
ModifyView::_Internal::collection(const ModifyView* msg) {
  return *msg->collection_;
}
const ::Mysqlx::Crud::Find&
ModifyView::_Internal::stmt(const ModifyView* msg) {
  return *msg->stmt_;
}
ModifyView::ModifyView()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.ModifyView)
}
ModifyView::ModifyView(const ModifyView& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      column_(from.column_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  definer_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_definer()) {
    definer_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.definer_);
  }
  if (from._internal_has_collection()) {
    collection_ = new ::Mysqlx::Crud::Collection(*from.collection_);
  } else {
    collection_ = nullptr;
  }
  if (from._internal_has_stmt()) {
    stmt_ = new ::Mysqlx::Crud::Find(*from.stmt_);
  } else {
    stmt_ = nullptr;
  }
  ::memcpy(&check_, &from.check_,
    static_cast<size_t>(reinterpret_cast<char*>(&security_) -
    reinterpret_cast<char*>(&check_)) + sizeof(security_));
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.ModifyView)
}

void ModifyView::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ModifyView_mysqlx_5fcrud_2eproto.base);
  definer_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&collection_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&stmt_) -
      reinterpret_cast<char*>(&collection_)) + sizeof(stmt_));
  check_ = 1;
  algorithm_ = 1;
  security_ = 1;
}

ModifyView::~ModifyView() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.ModifyView)
  SharedDtor();
}

void ModifyView::SharedDtor() {
  definer_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete collection_;
  if (this != internal_default_instance()) delete stmt_;
}

void ModifyView::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ModifyView& ModifyView::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ModifyView_mysqlx_5fcrud_2eproto.base);
  return *internal_default_instance();
}


void ModifyView::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.ModifyView)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  column_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      definer_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(collection_ != nullptr);
      collection_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(stmt_ != nullptr);
      stmt_->Clear();
    }
    check_ = 1;
    algorithm_ = 1;
    security_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* ModifyView::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .Mysqlx.Crud.Collection collection = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_collection(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string definer = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_definer();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .Mysqlx.Crud.ViewAlgorithm algorithm = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Mysqlx::Crud::ViewAlgorithm_IsValid(val))) {
            _internal_set_algorithm(static_cast<::Mysqlx::Crud::ViewAlgorithm>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .Mysqlx.Crud.ViewSqlSecurity security = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Mysqlx::Crud::ViewSqlSecurity_IsValid(val))) {
            _internal_set_security(static_cast<::Mysqlx::Crud::ViewSqlSecurity>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .Mysqlx.Crud.ViewCheckOption check = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Mysqlx::Crud::ViewCheckOption_IsValid(val))) {
            _internal_set_check(static_cast<::Mysqlx::Crud::ViewCheckOption>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated string column = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_column();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .Mysqlx.Crud.Find stmt = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_stmt(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ModifyView::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.ModifyView)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Crud.Collection collection = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::collection(this), target, stream);
  }

  // optional string definer = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_definer(), target);
  }

  // optional .Mysqlx.Crud.ViewAlgorithm algorithm = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_algorithm(), target);
  }

  // optional .Mysqlx.Crud.ViewSqlSecurity security = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_security(), target);
  }

  // optional .Mysqlx.Crud.ViewCheckOption check = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_check(), target);
  }

  // repeated string column = 6;
  for (int i = 0, n = this->_internal_column_size(); i < n; i++) {
    const auto& s = this->_internal_column(i);
    target = stream->WriteString(6, s, target);
  }

  // optional .Mysqlx.Crud.Find stmt = 7;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::stmt(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.ModifyView)
  return target;
}

size_t ModifyView::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.ModifyView)
  size_t total_size = 0;

  // required .Mysqlx.Crud.Collection collection = 1;
  if (_internal_has_collection()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *collection_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string column = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(column_.size());
  for (int i = 0, n = column_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      column_.Get(i));
  }

  // optional string definer = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_definer());
  }

  if (cached_has_bits & 0x0000003cu) {
    // optional .Mysqlx.Crud.Find stmt = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *stmt_);
    }

    // optional .Mysqlx.Crud.ViewCheckOption check = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_check());
    }

    // optional .Mysqlx.Crud.ViewAlgorithm algorithm = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_algorithm());
    }

    // optional .Mysqlx.Crud.ViewSqlSecurity security = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_security());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ModifyView::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ModifyView*>(
      &from));
}

void ModifyView::MergeFrom(const ModifyView& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.ModifyView)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  column_.MergeFrom(from.column_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      definer_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.definer_);
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from._internal_collection());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_stmt()->::Mysqlx::Crud::Find::MergeFrom(from._internal_stmt());
    }
    if (cached_has_bits & 0x00000008u) {
      check_ = from.check_;
    }
    if (cached_has_bits & 0x00000010u) {
      algorithm_ = from.algorithm_;
    }
    if (cached_has_bits & 0x00000020u) {
      security_ = from.security_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ModifyView::CopyFrom(const ModifyView& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.ModifyView)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModifyView::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  if (_internal_has_collection()) {
    if (!collection_->IsInitialized()) return false;
  }
  if (_internal_has_stmt()) {
    if (!stmt_->IsInitialized()) return false;
  }
  return true;
}

void ModifyView::InternalSwap(ModifyView* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  column_.InternalSwap(&other->column_);
  definer_.Swap(&other->definer_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(collection_, other->collection_);
  swap(stmt_, other->stmt_);
  swap(check_, other->check_);
  swap(algorithm_, other->algorithm_);
  swap(security_, other->security_);
}

std::string ModifyView::GetTypeName() const {
  return "Mysqlx.Crud.ModifyView";
}


// ===================================================================

void DropView::InitAsDefaultInstance() {
  ::Mysqlx::Crud::_DropView_default_instance_._instance.get_mutable()->collection_ = const_cast< ::Mysqlx::Crud::Collection*>(
      ::Mysqlx::Crud::Collection::internal_default_instance());
}
class DropView::_Internal {
 public:
  using HasBits = decltype(std::declval<DropView>()._has_bits_);
  static const ::Mysqlx::Crud::Collection& collection(const DropView* msg);
  static void set_has_collection(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_if_exists(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::Mysqlx::Crud::Collection&
DropView::_Internal::collection(const DropView* msg) {
  return *msg->collection_;
}
DropView::DropView()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Mysqlx.Crud.DropView)
}
DropView::DropView(const DropView& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_collection()) {
    collection_ = new ::Mysqlx::Crud::Collection(*from.collection_);
  } else {
    collection_ = nullptr;
  }
  if_exists_ = from.if_exists_;
  // @@protoc_insertion_point(copy_constructor:Mysqlx.Crud.DropView)
}

void DropView::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_DropView_mysqlx_5fcrud_2eproto.base);
  ::memset(&collection_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&if_exists_) -
      reinterpret_cast<char*>(&collection_)) + sizeof(if_exists_));
}

DropView::~DropView() {
  // @@protoc_insertion_point(destructor:Mysqlx.Crud.DropView)
  SharedDtor();
}

void DropView::SharedDtor() {
  if (this != internal_default_instance()) delete collection_;
}

void DropView::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DropView& DropView::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_DropView_mysqlx_5fcrud_2eproto.base);
  return *internal_default_instance();
}


void DropView::Clear() {
// @@protoc_insertion_point(message_clear_start:Mysqlx.Crud.DropView)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(collection_ != nullptr);
    collection_->Clear();
  }
  if_exists_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* DropView::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .Mysqlx.Crud.Collection collection = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_collection(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool if_exists = 2 [default = false];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_if_exists(&has_bits);
          if_exists_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DropView::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Mysqlx.Crud.DropView)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Mysqlx.Crud.Collection collection = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::collection(this), target, stream);
  }

  // optional bool if_exists = 2 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_if_exists(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields().data(),
        static_cast<int>(_internal_metadata_.unknown_fields().size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Mysqlx.Crud.DropView)
  return target;
}

size_t DropView::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Mysqlx.Crud.DropView)
  size_t total_size = 0;

  // required .Mysqlx.Crud.Collection collection = 1;
  if (_internal_has_collection()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *collection_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool if_exists = 2 [default = false];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields().size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DropView::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DropView*>(
      &from));
}

void DropView::MergeFrom(const DropView& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Mysqlx.Crud.DropView)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_collection()->::Mysqlx::Crud::Collection::MergeFrom(from._internal_collection());
    }
    if (cached_has_bits & 0x00000002u) {
      if_exists_ = from.if_exists_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DropView::CopyFrom(const DropView& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Mysqlx.Crud.DropView)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DropView::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (_internal_has_collection()) {
    if (!collection_->IsInitialized()) return false;
  }
  return true;
}

void DropView::InternalSwap(DropView* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(collection_, other->collection_);
  swap(if_exists_, other->if_exists_);
}

std::string DropView::GetTypeName() const {
  return "Mysqlx.Crud.DropView";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace Crud
}  // namespace Mysqlx
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::Mysqlx::Crud::Column* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Column >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Column >(arena);
}
template<> PROTOBUF_NOINLINE ::Mysqlx::Crud::Projection* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Projection >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Projection >(arena);
}
template<> PROTOBUF_NOINLINE ::Mysqlx::Crud::Collection* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Collection >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Collection >(arena);
}
template<> PROTOBUF_NOINLINE ::Mysqlx::Crud::Limit* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Limit >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Limit >(arena);
}
template<> PROTOBUF_NOINLINE ::Mysqlx::Crud::LimitExpr* Arena::CreateMaybeMessage< ::Mysqlx::Crud::LimitExpr >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::LimitExpr >(arena);
}
template<> PROTOBUF_NOINLINE ::Mysqlx::Crud::Order* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Order >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Order >(arena);
}
template<> PROTOBUF_NOINLINE ::Mysqlx::Crud::UpdateOperation* Arena::CreateMaybeMessage< ::Mysqlx::Crud::UpdateOperation >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::UpdateOperation >(arena);
}
template<> PROTOBUF_NOINLINE ::Mysqlx::Crud::Find* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Find >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Find >(arena);
}
template<> PROTOBUF_NOINLINE ::Mysqlx::Crud::Insert_TypedRow* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Insert_TypedRow >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Insert_TypedRow >(arena);
}
template<> PROTOBUF_NOINLINE ::Mysqlx::Crud::Insert* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Insert >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Insert >(arena);
}
template<> PROTOBUF_NOINLINE ::Mysqlx::Crud::Update* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Update >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Update >(arena);
}
template<> PROTOBUF_NOINLINE ::Mysqlx::Crud::Delete* Arena::CreateMaybeMessage< ::Mysqlx::Crud::Delete >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::Delete >(arena);
}
template<> PROTOBUF_NOINLINE ::Mysqlx::Crud::CreateView* Arena::CreateMaybeMessage< ::Mysqlx::Crud::CreateView >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::CreateView >(arena);
}
template<> PROTOBUF_NOINLINE ::Mysqlx::Crud::ModifyView* Arena::CreateMaybeMessage< ::Mysqlx::Crud::ModifyView >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::ModifyView >(arena);
}
template<> PROTOBUF_NOINLINE ::Mysqlx::Crud::DropView* Arena::CreateMaybeMessage< ::Mysqlx::Crud::DropView >(Arena* arena) {
  return Arena::CreateInternal< ::Mysqlx::Crud::DropView >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
